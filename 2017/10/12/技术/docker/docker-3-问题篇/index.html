<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="article">
<meta property="og:title" content="docker-3-问题篇">
<meta property="og:url" content="https://luojieio.github.io/2017/10/12/技术/docker/docker-3-问题篇/index.html">
<meta property="og:site_name" content="luojieio">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://luojieio.github.io/2017/10/12/技术/docker/docker-3-问题篇/0.png">
<meta property="og:updated_time" content="2018-03-14T03:11:18.177Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="docker-3-问题篇">
<meta name="twitter:image" content="https://luojieio.github.io/2017/10/12/技术/docker/docker-3-问题篇/0.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://luojieio.github.io/2017/10/12/技术/docker/docker-3-问题篇/"/>





  <title> docker-3-问题篇 | luojieio </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">luojieio</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">热爱开源、热爱自由</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://luojieio.github.io/2017/10/12/技术/docker/docker-3-问题篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luojieio">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/teaser.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="luojieio">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                docker-3-问题篇
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-12T20:05:10+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/12/技术/docker/docker-3-问题篇/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/12/技术/docker/docker-3-问题篇/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="/2017/10/12/技术/docker/docker-3-问题篇/0.png">
<p><br><br><a id="more"></a></p>
<blockquote>
<p>参考自：<br><a href="https://blog.lab99.org/post/docker-2016-07-14-faq.html#docker-yin-qing-xiang-guan-wen-ti-67" target="_blank" rel="noopener">https://blog.lab99.org/post/docker-2016-07-14-faq.html#docker-yin-qing-xiang-guan-wen-ti-67</a> 更新于2017年9月18日</p>
</blockquote>
<hr>
<h2 id="概念问题"><a href="#概念问题" class="headerlink" title="概念问题"></a>概念问题</h2><h3 id="宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么-Docker-和虚拟机还有什么差别？"><a href="#宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么-Docker-和虚拟机还有什么差别？" class="headerlink" title="宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么 Docker 和虚拟机还有什么差别？"></a>宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么 Docker 和虚拟机还有什么差别？</h3><p>这里要区别两个概念：<br>linux操作系统的发行版本与内核版本，以及操作系统的内核空间与用户空间<br>linux操作系统有很多发行版本，比如:ubuntu、centos、redhat等等，但是其使用的内核版本都是基于同一个版本的，所以说内核空间是相同的，但用户空间则有各大厂商按自己的设计思路进行顶层设计</p>
<p>另外要把 Windows 和 Linux 分清楚，更要把内核(<code>kernel</code>)和用户空间(<code>userland</code>)分清楚。容器内的进程是直接运行于宿主<code>内核</code>的，这点和宿主进程一致，只是容器的 <code>userland</code> 不同，容器的 <code>userland</code> 由容器镜像提供，也就是说镜像提供了 <code>rootfs</code>。假设宿主是 <code>Ubuntu</code>，容器是 <code>CentOS</code>。<code>CentOS</code> 容器中的进程会直接向 <code>Ubuntu</code> 宿主内核发送 <code>syscall</code>（系统调用），而不会直接或间接的使用任何 <code>Ubuntu</code> 的 <code>userland</code> 的库。</p>
<p>这点和虚拟机有本质的不同，虚拟机是虚拟环境，在现有系统上虚拟一套物理设备，然后在虚拟环境内运行一个虚拟环境的操作系统内核，在内核之上再跑完整系统，并在里面调用进程。</p>
<p>还以上面的例子去考虑，虚拟机中，<code>CentOS</code> 的进程发送 <code>syscall</code> 内核调用，该请求会被虚拟机内的 <code>CentOS</code> 的内核接到，然后 <code>CentOS</code> 内核访问虚拟硬件时，由虚拟机的服务软件截获，并使用宿主系统，也就是 <code>Ubuntu</code> 的内核及 <code>userland</code> 的库去执行。</p>
<p>而且，<code>Linux</code> 和 <code>Windows</code> 在这点上非常不同。Linux 的进程是直接发 <code>syscall</code> 的，而 <code>Windows</code> 则把 <code>syscall</code> 隐藏于一层层的 <code>DLL</code>（动态链接库） 服务之后，因此 Windows 的任何一个进程如果要执行，不仅仅需要 <code>Windows</code> 内核，还需要一群<code>服务</code>来支撑，所以如果 <code>Windows</code> 要实现类似的机制，容器内将不会像 <code>Linux</code> 这样轻量级，而是非常臃肿。看一下微软移植的 <code>Docker</code> 就非常清楚了。</p>
<p>所以不要把 <code>Docker</code> 和<code>虚拟机</code>弄混，<code>Docker</code> 容器只是一个进程而已，只不过利用镜像提供的 <code>rootfs</code> 提供了调用所需的 <code>userland</code> 库支持，使得进程可以在受控环境下运行而已，它并没有虚拟出一个机器出来。正因为docker只是一个进程而已，所以我们不能说docker是虚拟化，而更应该说是容器化，因为你总不能说父进程<code>fork</code>出来的子进程这种操作为虚拟化吧。</p>
<blockquote>
<p>参考：<br>(英文): <a href="https://www.docker.com/what-docker" target="_blank" rel="noopener">https://www.docker.com/what-docker</a><br>(中文): <a href="https://www.docker-cn.com/what-docker" target="_blank" rel="noopener">https://www.docker-cn.com/what-docker</a><br>视频笔记： <a href="https://blog.lab99.org/post/docker-2016-08-12-video-windows-server-and-docker.html" target="_blank" rel="noopener">Windows Server 和 Docker - John Starks</a></p>
</blockquote>
<hr>
<h3 id="Docker-资料好少啊？网上的命令怎么不能用？"><a href="#Docker-资料好少啊？网上的命令怎么不能用？" class="headerlink" title="Docker 资料好少啊？网上的命令怎么不能用？"></a>Docker 资料好少啊？网上的命令怎么不能用？</h3><p>学好英语，多用google，多看官方文档</p>
<p>(英文): <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a><br>(中文): <a href="https://docs.docker-cn.com" target="_blank" rel="noopener">https://docs.docker-cn.com</a> (文档有坑，不少代码格式有错)<br>(老麦的翻译): <a href="https://docker2.octowhale.com/" target="_blank" rel="noopener">https://docker2.octowhale.com/</a></p>
<p>另外，Docker有丰富的镜像库，Docker Hub，特别是官方(Official)的镜像可以直接在生产环境中使用，制作比较精良。<code>https://hub.docker.com/explore/</code>，所有的官方镜像都有 <code>Dockerfile</code>，以及在<code>github</code>上有全部生成镜像的配套文件，遵循了<code>Dockerfile</code>的最佳实践，这些也是很好地学习资料。</p>
<p>另外，在 YouTube 的 Docker 官方频道下有几百个视频讲座，从初级到高级用户都能从里面学到很多东西。<code>https://www.youtube.com/user/dockerrun</code></p>
<hr>
<h3 id="如何选择-Docker-书籍？"><a href="#如何选择-Docker-书籍？" class="headerlink" title="如何选择 Docker 书籍？"></a>如何选择 Docker 书籍？</h3><p>Docker 属于敏捷开发的产品，并且处于高速创新阶段，每年都会有很多版本发布。由于这种快速开发的特性，Docker 一般只保留几个版本内的向后兼容性，再之后就会废弃。因此选择图书的时候，<code>不应该选择比当前版本低超过2-3个版本的书籍</code>。换句话说，市面上大部分书籍，特别是中文书籍、网文，很可能都过时了。</p>
<p> Docker 版本号在 2017 年以前，使用 <code>&lt;大版本号&gt;.&lt;小版本号&gt;.&lt;补丁版本号&gt;</code>的结构，那时 Docker 基本会保持 <code>3 个小版本号</code> 之内的兼容性（如果一个特性宣布废弃，一般会在 3 个版本后才彻底移除）。</p>
<p>而从 2017 年春以后，Docker 使用了新版本号结构：<code>&lt;年&gt;.&lt;月&gt;.&lt;补丁版本号&gt;</code>，并且将每月发布一个<code>前沿(Edge)版本</code>，每季度发布一个<code>稳定(Stable)版本</code>。因此选择书籍也应该以介绍<code>2-3个季度以内版本</code> 的书籍为准。那些介绍一年以前发布的 Docker 版本的书籍不应该再看了。</p>
<p>因此在购买 Docker 图书的时候，应该遵循这样的原则：<code>观察一下当前的 Docker 版本号，选择不要晚于 3 个版本的 Docker 书籍（也可以看看书的出版日期，选择就近原则）</code>。 比如写这段文字时为 <code>17.06</code>，那么就不要购买介绍 Docker <code>1.12</code> 及其以前版本的书籍了，否则看到的很多东西可能将会因过时而无法使用，或者已经不必如此繁琐有更简单的方式去实现了。</p>
<p>所以，对于 Docker 学习而言，<code>最好的书籍是官网文档</code>，官网的文档很丰富。</p>
<ul>
<li>新手教程：<ul>
<li>（英文）：<a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">https://docs.docker.com/get-started/</a></li>
<li>（中文）：<a href="https://docs.docker-cn.com/get-started/" target="_blank" rel="noopener">https://docs.docker-cn.com/get-started/</a></li>
</ul>
</li>
<li>Docker 课程：<a href="http://training.play-with-docker.com/" target="_blank" rel="noopener">http://training.play-with-docker.com/</a><ul>
<li>运维人员课程：<a href="http://training.play-with-docker.com/ops-landing/" target="_blank" rel="noopener">http://training.play-with-docker.com/ops-landing/</a></li>
<li>开发人员课程：<a href="http://training.play-with-docker.com/dev-landing/" target="_blank" rel="noopener">http://training.play-with-docker.com/dev-landing/</a></li>
</ul>
</li>
<li>大量的例子：<ul>
<li>（英文）：<a href="https://docs.docker.com/samples/" target="_blank" rel="noopener">https://docs.docker.com/samples/</a></li>
<li>（中文）：<a href="https://docs.docker-cn.com/samples/" target="_blank" rel="noopener">https://docs.docker-cn.com/samples/</a></li>
</ul>
</li>
<li>用户文档：<ul>
<li>（英文）：<a href="https://docs.docker.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/</a></li>
<li>（中文）：<a href="https://docs.docker-cn.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker-cn.com/engine/userguide/</a></li>
<li>镜像：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></li>
<li>存储：<a href="https://docs.docker.com/engine/userguide/storagedriver/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/storagedriver/</a></li>
<li>网络：<a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/</a></li>
</ul>
</li>
<li>管理文档：<a href="https://docs.docker.com/engine/admin/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/</a><ul>
<li>存储：<a href="https://docs.docker.com/engine/admin/volumes/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/volumes/</a></li>
</ul>
</li>
<li>安全：<a href="https://docs.docker.com/engine/security/security/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/security/</a></li>
<li>集群：<a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/</a></li>
</ul>
<p>部分文档有对应官方的中文翻译，可以从 <code>https://docs.docker-cn.com</code> 查看。但是一定要<code>注意代码格式</code>，中文文档中许多格式是错误的，应该对比英文文档中的代码来看。</p>
<p>对于新手而言，应该先从新手教程开始，内容还是很简单易懂的，很容易上手。然后，可以把用户文档好好看一遍，里面把很多 Docker 的基础概念讲的很清楚。概念清晰后，可以去把官网给出的例子好好的学习一下，这些例子都是具体怎么应用 Docker 的，有文字说明以及具体的考虑，很适合学习。</p>
<hr>
<h3 id="Docker-官网文档被墙，看不了怎么办？"><a href="#Docker-官网文档被墙，看不了怎么办？" class="headerlink" title="Docker 官网文档被墙，看不了怎么办？"></a>Docker 官网文档被墙，看不了怎么办？</h3><p> 我们可以本地运行 Docker 官方文档的网站，以 docker 的方式：<br> <code>$ docker run -d -p 80:4000 docs/docker.github.io</code><br>这样访问 Docker 宿主的 80 端口，如 <code>http://localhost</code>，就会看到官网文档了。</p>
<p> 那些访问不了<code>问答录</code>的童鞋，同样可以用这样的方式来本地运行：<br> <code>$ docker run -d -p 80:80 twang2218/blog.lab99.org</code><br>然后就可以访问本地 80 端口看到最新的问答录了。</p>
<hr>
<h3 id="Docker-1-8-以后版本都有什么改进么？"><a href="#Docker-1-8-以后版本都有什么改进么？" class="headerlink" title="Docker 1.8 以后版本都有什么改进么？"></a>Docker 1.8 以后版本都有什么改进么？</h3><p> 每个版本发布时，官方博客 <code>https://blog.docker.com</code> 都会有专门文章描述这个版本最主要的改进。</p>
<ul>
<li><code>1.9</code>: <a href="https://blog.docker.com/2015/11/docker-1-9-production-ready-swarm-multi-host-networking/" target="_blank" rel="noopener">https://blog.docker.com/2015/11/docker-1-9-production-ready-swarm-multi-host-networking/</a></li>
<li><code>1.10</code>: <a href="https://blog.docker.com/2016/02/docker-1-10/" target="_blank" rel="noopener">https://blog.docker.com/2016/02/docker-1-10/</a></li>
<li><code>1.11</code>: <a href="https://blog.docker.com/2016/04/docker-engine-1-11-runc/" target="_blank" rel="noopener">https://blog.docker.com/2016/04/docker-engine-1-11-runc/</a></li>
<li><code>1.12</code>: <a href="https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/" target="_blank" rel="noopener">https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/</a></li>
</ul>
<p>另外，可以看一下孙宏亮维护的《<a href="https://github.com/allencloud/docker-changelog-chinese" target="_blank" rel="noopener">Docker 中文 Changelog</a>》：</p>
<ul>
<li><code>1.10</code>: <a href="https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.10.0-changelog.md" target="_blank" rel="noopener">https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.10.0-changelog.md</a></li>
<li><code>1.11</code>: <a href="https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.11.0-changelog.md" target="_blank" rel="noopener">https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.11.0-changelog.md</a></li>
<li><code>1.11.1</code>: <a href="https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.11.1-changelog.md" target="_blank" rel="noopener">https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.11.1-changelog.md</a></li>
<li><code>1.12</code>: <a href="https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.12.0-changelog.md" target="_blank" rel="noopener">https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.12.0-changelog.md</a></li>
</ul>
<blockquote>
<p>关于 <code>Docker 1.13</code> 可以看一下我写的《<a href="https://blog.lab99.org/post/docker-2016-11-14-what-is-new-in-docker-1-13.html" target="_blank" rel="noopener">Docker 1.13 新增功能</a>》。</p>
</blockquote>
<hr>
<h3 id="（自加）docker与LXC（linux-container）有何不同"><a href="#（自加）docker与LXC（linux-container）有何不同" class="headerlink" title="（自加）docker与LXC（linux container）有何不同?"></a>（自加）docker与LXC（linux container）有何不同?</h3><p>LXC利用Linux上相关技术实现了容器。docker则在如下的几个方面进行了改进：</p>
<ul>
<li>移植性：通过抽象容器配置，容器可以实现从一个平台移植到另一个平台</li>
<li>镜像系统：基于AUFS的镜像系统为容器的分发带来了很多便利，同时共同的镜像层只需要存储一份，实现了高效率的存储</li>
<li>版本管理：类似于Git的版本管理理念，用户可以更方便的创建、管理镜像文件</li>
<li>仓库系统：仓库系统大大降低了镜像的分发和管理的成本</li>
<li>周边工具：各种现有工具（配置管理、云平台）对docker的支持，以及基于docker的PaaS、CI等系统，让Docker的应用更加方便和多样化。</li>
</ul>
<hr>
<h3 id="（自加）docker与vagrant有何不同？"><a href="#（自加）docker与vagrant有何不同？" class="headerlink" title="（自加）docker与vagrant有何不同？"></a>（自加）docker与vagrant有何不同？</h3><p>两者的定位完全不同</p>
<ul>
<li>vagrant类似于boot2docker（一款运行docker的最小内核），是一套虚拟机的管理环境。vagrant可以在多种系统上和虚拟机软件中运行，可以在windows/mac等非Linux平台上为docker提供支持，自身具有较好的包装性和移植性。（vagrant是依赖于虚拟机的快照运行的，所以说白了可以理解为一个虚拟机插件，也可以方便开发环境的统一，弥补docker在开发环境统一的不足，因为开发环境大多在windows环境，而docker并不支持运行windows，这点正好是vagrant可以借助虚拟机来实现的）</li>
<li>原生的docker自身只能运行在Linux平台上，但启动和运行的性能都比虚拟要快，往往更适合快速开发和部署应用的场景。<br>简单说：vagrant适合用来管理虚拟机（或开发环境统一），而docker适合用来管理应用环境（或测试环境与生产环境的统一）</li>
</ul>
<hr>
<h3 id="（自加）开发环境中docker和vagrant该如何选择？"><a href="#（自加）开发环境中docker和vagrant该如何选择？" class="headerlink" title="（自加）开发环境中docker和vagrant该如何选择？"></a>（自加）开发环境中docker和vagrant该如何选择？</h3><p>docker不是虚拟机，而是进程隔离，对于资源的消耗很少，但是目前需要linux环境支持。vagrant是虚拟机上做的封装，虚拟机本身会消耗资源。</p>
<ul>
<li>如果本地开发环境使用的是Linux环境，推荐使用docker</li>
<li>如果本地开发环境使用的是OSX或Windows环境，那就需要开虚拟机，单一开发环境下vagrant更简单，多环境开发下推荐在vagrant里再使用docker进行环境隔离</li>
</ul>
<hr>
<h3 id="（自加）docker能在非linux平台（比如windows或macos）上运行吗？"><a href="#（自加）docker能在非linux平台（比如windows或macos）上运行吗？" class="headerlink" title="（自加）docker能在非linux平台（比如windows或macos）上运行吗？"></a>（自加）docker能在非linux平台（比如windows或macos）上运行吗？</h3><p>可以，但需要使用boot2docker等软件创建一个轻量级的linux虚拟机层</p>
<hr>
<h3 id="（自加）docker的宿主系统是centos，为什么可以运行ubuntu的镜像呢？"><a href="#（自加）docker的宿主系统是centos，为什么可以运行ubuntu的镜像呢？" class="headerlink" title="（自加）docker的宿主系统是centos，为什么可以运行ubuntu的镜像呢？"></a>（自加）docker的宿主系统是centos，为什么可以运行ubuntu的镜像呢？</h3><p>其实就是复用的linux内核的一些东西，而centos和ubuntu是基于linux内核开发的</p>
<p>首先需要区分Linux内核与Linux发行版</p>
<p>Linux内核是Linux操作系统的核心, 负责硬件管理, 比如管理内存、管理磁盘（文件系统）、管理CPU(进程)等等…<br>Linux发行版是在Linux内核的基础上添加了一些工具软件,比如图形界面、函数库、软件包管理系统等等…<br>CentOS与Ubuntu是不同的Linux发行版, 它们都是基于Linux内核， 只是添加的工具软件不同。比如， 他们的软件包管理系统不同， CentOS使用yum命令安装软件， 而Ubuntu使用apt-get命令安装软件。</p>
<p>因此CentOS与Ubuntu的内核是相同的(版本可能不同), 只是所安装的软件不同， 即文件系统不同。</p>
<p>Docker容器技术是基于Linux内核实现的， 它主要用到了两个内核模块:</p>
<p>Namespace： 用于容器的隔离， 例如PID Namespace使得容器中的进程无法感知宿主机以及其他容器中的进程。<br>Cgroups: 用于容器的资源控制， 比如限制容器所使用的内存大小或者CPU个数。</p>
<p>在CentOS上运行基于Ubuntu镜像的容器时, 容器使用了CentOS主机的内核以及Ubuntu镜像, Ubuntu镜像中安装了Ubuntu的各种软件(apt-get)。</p>
<hr>
<h2 id="安装、配置问题"><a href="#安装、配置问题" class="headerlink" title="安装、配置问题"></a>安装、配置问题</h2><h3 id="Docker-怎么这么多软件，我该装哪个？"><a href="#Docker-怎么这么多软件，我该装哪个？" class="headerlink" title="Docker 怎么这么多软件，我该装哪个？"></a>Docker 怎么这么多软件，我该装哪个？</h3><p>好吧，我决定要装 Docker 了，于是来打开 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">Docker 安装文档</a> (<a href="https://docs.docker-cn.com/engine/installation/" target="_blank" rel="noopener">中文</a> 看看怎么装吧……呃，然后就傻了，怎么这么多种选择啊？！</p>
<p>首先，Docker 有好几个<code>版本</code>:</p>
<ul>
<li>社区版（Community Edition）</li>
<li>企业版（Enterprise Edition）<ul>
<li>企业基础版（Enterprise Edition Basic）</li>
<li>企业标准版（Enterprise Edition Standard）</li>
<li>企业高级版（Enterprise Edition Advanced）</li>
</ul>
</li>
</ul>
<p>对于我们一般学习使用而言，使用<code>社区版</code>就已足够，所以记住<code>CE</code>就可以了。</p>
<p>确定好发行版本后，接下来我们要针对自己的平台选择安装方式了。我们会看到一堆平台特定的版本：</p>
<ul>
<li>Docker for Mac</li>
<li>Docker for Windows</li>
<li>Docker Toolbox</li>
<li>Docker for Azure</li>
<li>Docker for AWS 等等</li>
<li>对于 Linux 的发行版。也有ubuntu、centos等等。</li>
</ul>
<p>那我们应该用哪个？其实不难选择，这都是平台特定的东西嘛，选择自己平台就完了：</p>
<ul>
<li>macOS 就选择 <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker for Mac</a>；<ul>
<li>阿里云（未及时更新）：<a href="https://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/stable/" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/stable/</a></li>
</ul>
</li>
<li>Linux 就选择自己平台的 Docker 源：<ul>
<li>Ubuntu: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/</a></li>
<li>Debian: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/debian/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/debian/</a></li>
<li>CentOS: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/centos/</a></li>
<li>Fedora: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/fedora/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/fedora/</a></li>
</ul>
</li>
<li>Windows 要麻烦些：<ul>
<li>如果是 <code>Windows 10 专业版、企业版、教育版</code>，并且版本在 <code>10586</code> 以后，并且<code>不打算</code>在 Docker 运行<code>同时</code>再运行其它虚拟机的情况下，可以装 <a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="noopener">Docker for Windows</a>。<ul>
<li>阿里云（未及时更新）：<a href="https://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/stable/" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/stable/</a></li>
</ul>
</li>
<li><code>其它情况</code>都装 <a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a><ul>
<li>阿里云：<a href="https://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a></li>
</ul>
</li>
</ul>
</li>
<li>如果是特定云服务平台，可以考虑特定服务平台的版本（当然，这不是必须）：<ul>
<li>AWS：<a href="https://docs.docker.com/docker-for-aws/" target="_blank" rel="noopener">Docker for AWS</a></li>
<li>Azure：<a href="https://docs.docker.com/docker-for-azure/" target="_blank" rel="noopener">Docker for Azure</a></li>
</ul>
</li>
</ul>
<p>最后是<code>发布通道</code>，从今年初开始，也就是从 <code>1.13</code> 以后，Docker 使用了新的版本号规则，将采用类似 Ubuntu 那种<code>&lt;年&gt;.&lt;月&gt;</code> 的形式，比如 <code>17.03</code>, <code>17.06</code>等。并且，将发布通道分为前<code>沿版本(Edge)</code>和<code>稳定版本(Stable)</code>。前沿通道将基本<code>每个月发布一个版本</code>，而稳定通道将基本<code>每3个月</code>发布一个版本。这样 Docker 的发布将有规律可寻。对于喜欢尝鲜的可以选择前沿版本，对于需要稳定的，可以选择稳定版本。</p>
<blockquote>
<p>这里面需要注意的是，在参考<a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官方安装文档</a> (<a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">中文</a>)配置 Linux 源的时候，如果是国内服务器，要将其中的 <code>https://download.docker.com/linux/</code> 替换为<code>https://mirrors.aliyun.com/docker-ce/linux/</code>。这样速度会比较快。</p>
</blockquote>
<p>比如，文档如果要求执行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure></p>
<p>那么就<code>替换</code>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>
<p>这样安装 Docker 就会使用阿里云的软件源，而不需要翻墙了。（注：这不是加速器，不要搞错了，加速器依旧需要配！）</p>
<hr>
<h3 id="是直接用-yum-apt-get-安装-Docker-吗？"><a href="#是直接用-yum-apt-get-安装-Docker-吗？" class="headerlink" title="是直接用 yum / apt-get 安装 Docker 吗？"></a>是直接用 yum / apt-get 安装 Docker 吗？</h3><p> 很多人问到 <code>docker</code>, <code>docker.io</code>, <code>docker-engine</code> 甚至 <code>lxc-docker</code> 都有什么区别？</p>
<ul>
<li>RHEL/CentOS 软件源中的 Docker 包名为 <code>docker</code>；</li>
<li>Ubuntu 软件源中的 Docker 包名为 <code>docker.io</code>；</li>
<li>而很古老的 Docker 源中 Docker 也曾叫做 <code>lxc-docker</code>。这些都是非常老旧的 Docker 版本，并且基本不会更新到最新的版本，而对于使用 Docker 而言，使用最新版本非常重要。</li>
<li>17.04 以后，包名从 <code>docker-engine</code> 改为 <code>docker-ce</code>，因此从现在开始安装，应该都使用 <code>docker-ce</code> 这个包。</li>
</ul>
<blockquote>
<p>提示：不要使用操作系统提供的软件源中的 Docker 包，去使用 Docker 官方源的包，因为操作系统提供的软件源中的包往往比较旧。</p>
</blockquote>
<p>正确的安装方法有两种：</p>
<ul>
<li>一种是参考官方安装文档去配置 <code>apt</code> 或者 <code>yum</code>的源；</li>
<li>另一种则是使用官方提供的<code>安装脚本</code>快速安装。</li>
</ul>
<blockquote>
<p>官方文档对配置源的方法已经有很详细的讲解，这里就不赘述，需要的直接去看<a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<p>这里只介绍使用官方的脚本快速安装：</p>
<h4 id="17-04-及以后的版本"><a href="#17-04-及以后的版本" class="headerlink" title="17.04 及以后的版本:"></a>17.04 及以后的版本:</h4><p>从 <code>17.04</code> 以后，可以用下面的命令安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CHANNEL=stable</span><br><span class="line">curl -fsSL https://get.docker.com/ | sh -s -- --mirror Aliyun</span><br></pre></td></tr></table></figure></p>
<p>这里使用的是官方脚本安装，通过环境变量指定安装通道为 <code>stable</code>，（如果喜欢尝鲜可以改为 <code>edge</code>,<code>test</code>），并且指定使用阿里云的源(apt/yum)来安装 Docker CE 版本。</p>
<h4 id="17-03-及以前的版本"><a href="#17-03-及以前的版本" class="headerlink" title="17.03 及以前的版本:"></a>17.03 及以前的版本:</h4><p>早期的版本可以使用阿里云或者 DaoCloud 老的脚本安装：<br>使用<code>阿里云</code>的安装脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure>
<p>使用<code>DaoCloud</code>的Docker安装脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="不是都已经发布-Docker-17-07-了么？我怎么升级到最新还是-17-05-呀？"><a href="#不是都已经发布-Docker-17-07-了么？我怎么升级到最新还是-17-05-呀？" class="headerlink" title="不是都已经发布 Docker 17.07 了么？我怎么升级到最新还是 17.05 呀？"></a>不是都已经发布 Docker 17.07 了么？我怎么升级到最新还是 17.05 呀？</h3><p>从 <code>17.04</code> 以后，Docker 的源的结构以及包名都进行了调整，因此如果你你还使用的是旧的源，那么需要参照<a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官方文档</a>，更新源的地址为新的源。前面的问答中已经给出了链接和替代用的阿里云源镜像地址，参照修改（apt/yum）源。修改好后，卸载旧的 <code>docker-engine</code>，安装新的 <code>docker-ce</code> 即可。</p>
<hr>
<h3 id="docker-pull-好慢啊怎么办？"><a href="#docker-pull-好慢啊怎么办？" class="headerlink" title="docker pull 好慢啊怎么办？"></a>docker pull 好慢啊怎么办？</h3><p>我们可以使用 Docker 镜像加速器来解决这个问题，加速器就是镜像、代理的概念。国内有不少机构提供了免费的加速器以方便大家使用，这里列出一些常用的加速器服务：</p>
<ul>
<li><a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">Docker 官方的中国镜像加速器</a>：从2017年6月9日起，<code>Docker 官方提供了在中国的加速器</code>，以解决墙的问题。不用注册，直接使用加速器地址：<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 即可。</li>
<li><a href="http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker" target="_blank" rel="noopener">中国科技大学的镜像加速器</a>：中科大的加速器不用注册，直接使用地址 <a href="https://docker.mirrors.ustc.edu.cn/" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn/</a> 配置加速器即可。进一步的信息可以访问：<a href="http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker</a></li>
<li><a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>：注册阿里云开发账户(<code>免费的</code>)后，访问这个链接就可以看到加速器地址： <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/accelerator</a></li>
<li><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a>：<a href="http://account.daocloud.io/signup" target="_blank" rel="noopener">注册 DaoCloud 账户</a>(<code>支持微信登录</code>)，然后访问： <a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></li>
</ul>
<blockquote>
<p>注意：<code>不要使用</code>加速器网站所给的配置脚本，容易导致错误。我们只需获取其提供的<code>加速器地址</code>即可。</p>
</blockquote>
<hr>
<h3 id="如何使用加速器？"><a href="#如何使用加速器？" class="headerlink" title="如何使用加速器？"></a>如何使用加速器？</h3><h4 id="Ubuntu-14-04-配置加速器（或其它使用-Upstart-的系统）"><a href="#Ubuntu-14-04-配置加速器（或其它使用-Upstart-的系统）" class="headerlink" title="Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统）"></a>Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统）</h4><blockquote>
<p><code>Ubuntu 14.04</code> 是使用 <code>upstart</code> 进行系统初始化的，对于这类系统，可以用通过编辑配置文件的方法来配置加速器。<br>如果是 <code>Ubuntu 14.04</code>，那么编辑 <code>/etc/default/docker</code>，在里面寻找 <code>DOCKER_OPTS</code> 环境变量设置的这一行，在其后添加 <code>-–registry-mirror=&lt;加速器地址&gt;</code>。如果发现该行已被注释，或者不存在该行，那么新添一行即可。</p>
</blockquote>
<p>比如，在使用官方源安装了 <code>docker-engine</code> 后，会建立一个默认的 <code>/etc/default/docker</code>，其中相关 <code>DOCKER_OPTS</code> 的行是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Use DOCKER_OPTS to modify the daemon startup options.</span><br><span class="line">#DOCKER_OPTS=&quot;--dns 8.8.8.8 --dns 8.8.4.4&quot;</span><br></pre></td></tr></table></figure>
<p>假设我们的加速器地址为<code>https://registry.docker-cn.com</code>，我们添加一行配置，将其改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Use DOCKER_OPTS to modify the daemon startup options.</span><br><span class="line">#DOCKER_OPTS=&quot;--dns 8.8.8.8 --dns 8.8.4.4&quot;</span><br><span class="line">DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;</span><br></pre></td></tr></table></figure>
<p>保存文件后，重启 Docker 引擎：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br><span class="line">docker stop/waiting</span><br><span class="line">docker start/running, process 3620</span><br></pre></td></tr></table></figure>
<p>重启成功后，确认一下配置是否已经生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ps -ef | grep dockerd</span><br><span class="line">root      3620     1  0 04:26 ?        00:00:00 /usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com --raw-logs</span><br></pre></td></tr></table></figure>
<p>如果配置成功，生效后这里就会看到自己所配置的加速器的内容。</p>
<h4 id="Ubuntu-16-04-或-CentOS-7-配置加速器（或其它使用-Systemd-的系统）"><a href="#Ubuntu-16-04-或-CentOS-7-配置加速器（或其它使用-Systemd-的系统）" class="headerlink" title="Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）"></a>Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）</h4><p><code>Ubuntu 16.04</code> 和 <code>CentOS 7</code> 这类系统都已经开始使用 <code>systemd</code> 进行系统初始化管理了，对于使用<code>systemd</code>的系统，应该通过编辑服务配置文件 <code>docker.service</code> 来进行加速器的配置。</p>
<p>在启用服务后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
<p>可以直接编辑 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code>文件来进行配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/systemd/system/multi-user.target.wants/docker.service</span><br></pre></td></tr></table></figure>
<p>在文件中找到<code>ExecStart=</code>这一行，并且在其行尾添加上所需的配置。假设我们的加速器地址为<code>https://registry.docker-cn.com</code>,那么可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注: Docker 1.12 之前的版本，dockerd 应该换为 <code>docker daemon</code>，更早的版本则是<code>docker -d</code>。不过还在用那些版本的童鞋，升级吧</p>
</blockquote>
<p>保存退出后，重新加载配置并启动服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>确认一下配置是否已经生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ps -ef | grep dockerd</span><br></pre></td></tr></table></figure>
<p>如果配置成功，生效后就会在这里看到自己所配置的加速器。</p>
<p>在 <code>1.13</code> 版本以后，可以直接 <code>docker info</code> 查看，如果配置成功，加速器 <code>Registry Mirror</code> 会在最下面列出来。</p>
<p>如果重启后发现无法启动 <code>docker</code> 服务，检查一下服务日志，看看是不是之前执行过那些加速器网站的脚本，如果有做过类似的事情，检查一下是不是被建立了<code>/etc/docker/daemon.json</code>以配置加速器，如果是的话，删掉这个文件，然后在重启服务。</p>
<p>使用配置文件是件好事，比如修改配置不必重启服务，只需发送 <code>SIGHUP</code> 信号即可。但需要注意，目前在<code>dockerd</code> 中使用配置文件时，无法输出当前生效配置，并且当 <code>dockerd</code> 的参数和 <code>daemon.json</code> 文件中的配置有所重复时，并不是一个优先级覆盖另一个，而是会直接导致引擎启动失败。很多人发现配了加速器后 Docker 启动不起来了就是这个原因。解决办法很简单，去掉重复项。不过在这些问题解决前，建议使用修改<code>docker.service</code> 这类做法来实现配置，而不是使用配置文件<code>daemon.json</code>。方便 <code>ps -ef | grep dockerd</code> 一眼看到实际配置情况。</p>
<hr>
<h3 id="怎么修改了-docker-服务配置后不起作用？"><a href="#怎么修改了-docker-服务配置后不起作用？" class="headerlink" title="怎么修改了 docker 服务配置后不起作用？"></a>怎么修改了 docker 服务配置后不起作用？</h3><p>改动真的生效了么？在宿主上运行一下 <code>ps -ef | grep dockerd</code> 看看，自己做的那些配置有么？没有的话就说明没有生效，那么就要检查原因了。</p>
<p>首先，改完配置重启服务了么？虽然这个问题看着很小白，但是确实很多人犯了这个小白的错误。</p>
<ul>
<li><code>Ubuntu 14.04</code>: <code>sudo service docker restart</code></li>
<li><code>Ubuntu 16.04, CentOS 7</code>: <code>sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</code></li>
</ul>
<p>另外，你改对了配置文件了么？<br>不少人懒得看英文文档，百度个文章就照着配，既不管百度得到的文章所讲的系统，也没注意版本，而且中文文章往往自身表达描述不清楚，很多想当然的东西，结果无数坑。这么百度的人，很有可能压根就改错了文件。</p>
<blockquote>
<p>珍爱生命，远离百度。</p>
</blockquote>
<p>最近两年处于 <code>upstart</code> 到 <code>systemd</code> 的过渡期，所以配置服务的方式对于不同的系统版本是不一样的，要看看自己使用的是什么操作系统，以及什么版本。</p>
<p>对于 <code>upstart</code> 的系统（<code>Ubuntu 14.10</code>或以前的版本，<code>Debian 7</code>或以前的版本），配置文件可能在 <code>/etc/default/docker</code>，其配置方式基本是配置 <code>DOCKER_*</code> 的环境变量。</p>
<p>而对于 <code>systemd</code> 的系统(<code>Ubuntu 15.04</code>及以后的版本，<code>Debian 8</code>及以后的版本，<code>CentOS 7</code>/<code>RHEL 7</code>及以后的版本)，配置文件则在 <code>systemd</code> 的配置目录下。<br>首先应该 <code>enable</code>（启用） 该服务：<br><code>sudo systemctl enable docker</code><br>然后修改配置文件 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code> （只要服务 <code>enable</code> 了，那么不管什么系统，应该都会在这个位置看到配置文件）</p>
<blockquote>
<p>要注意 <code>upstart</code> 的服务配置文件和 <code>systemd</code> 的配置文件的格式是不同的，不要拿着 <code>upstart</code> 的配置行直接复制粘贴到 <code>systemd</code> 的配置文件里，两码事儿，请先学习基础知识。</p>
<p>参考官网文档：<br><a href="https://docs.docker.com/engine/admin/configuring/#ubuntu" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/configuring/#ubuntu</a><br><a href="https://docs.docker.com/engine/admin/systemd/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/systemd/</a></p>
</blockquote>
<hr>
<h3 id="如果-Docker-升级或者重启的话，那容器是不是都会被停掉然后重启啊？"><a href="#如果-Docker-升级或者重启的话，那容器是不是都会被停掉然后重启啊？" class="headerlink" title="如果 Docker 升级或者重启的话，那容器是不是都会被停掉然后重启啊？"></a>如果 Docker 升级或者重启的话，那容器是不是都会被停掉然后重启啊？</h3><p>在 <code>1.12</code> 以前的版本确实如此，但是从 <code>1.12</code> 开始，Docker 引擎加入了 <code>--live-restore</code> 参数，使用该参数可以避免引擎升级、重启导致容器停止服务的情况。</p>
<p>默认情况该功能不会被启动，如需启动，需要配置 docker 服务配置文件。比如 <code>Ubuntu 16.04</code> 这类 <code>systemd</code>的系统，可以修改 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code>文件，在 <code>ExecStart=</code> 后面配置上<code>--live-restore</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd \</span><br><span class="line">    --registry-mirror=https://registry.docker-cn.com \</span><br><span class="line">    --live-restore</span><br></pre></td></tr></table></figure>
<p>上面的格式中使用了行尾 <code>\</code> 的换行形式，这点和<code>bash</code> 脚本一样，<code>systemd</code> 支持这种换行形式，如对此不了解可以先去学习 <code>bash</code> 程序设计。</p>
<p>需要注意的是，<code>--live-restore</code> 和 <code>Swarm Mode</code> 不兼容，所以在集群环境中不要使用。实际上集群环境也不用担心某个服务器重启的问题，因为其上的服务都会被调度到别的节点上，因此服务并不会被中断。</p>
<blockquote>
<p>参考文档：<br><a href="https://docs.docker.com/engine/admin/live-restore/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/live-restore/</a></p>
</blockquote>
<hr>
<h3 id="为什么执行-docker-命令会报-permission-denied-没权限的错误啊？"><a href="#为什么执行-docker-命令会报-permission-denied-没权限的错误啊？" class="headerlink" title="为什么执行 docker 命令会报 permission denied 没权限的错误啊？"></a>为什么执行 docker 命令会报 permission denied 没权限的错误啊？</h3><p>在 Linux 环境下，一些新装了 docker 的用户，特别是使用了 <code>sudo</code>命令安装好了 <code>Docker</code> 后，发现当前用户一执行 docker 命令，就会报没权限的错误：<br><code>dial unix /var/run/docker.sock: permission denied</code></p>
<p> 一些来自于 Windows 世界的人，就会蹦出来说，用 <code>root</code> 。而另一些有基本常识、知道不应该使用 <code>root</code> 人可能会说，那就用 <code>sudo docker</code> 吧。这两者都是不对的，或者说不合适的。</p>
<p>说使用 <code>root</code> 的人，应该回去好好学习一下 Linux 权限常识。<code>一般 不应该直接使用 root 用户</code>，直接使用 <code>root</code> 用户不仅仅是严重的违反了安全规范，而且也极容易造成操作事故。这不是 Windows 世界，Linux/Unix 世界是有严格的权限要求的，只应该<code>使用最小的权限做事情</code>。如果还不熟悉 Linux 权限机制，那就去学习一下，不要把 Windows 的坏毛病带过来。</p>
<p>说使用 <code>sudo docker</code> 的人，思路是对的，因为理解了平时操作应该使用普通用户，只有在需要的时候，才 <code>sudo</code> 提升权限进行操作。但是问题就在这个<code>需要</code>二字上，事实上，<code>不需要 root 权限就可以执行 docker 命令</code>。</p>
<p>其实如果看过<a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">官方安装文档</a>的话都会知道，只需要将操作 <code>docker</code> 的用户，加入 <code>docker</code> 组，那么该用户既拥有了操作 <code>docker</code> 的权限。</p>
<p>因此，只需要执行：<br><code>sudo usermod -aG docker $USER</code></p>
<p>就可以把当前用户加入<code>docker 组</code>，<code>退出、重新登录系统后</code>，执行<code>docker info</code> 看一下，就会发现可以不用 <code>sudo</code> 直接执行 <code>docker</code> 命令了。</p>
<p>如果需要添加别的用户，将其中的 <code>$USER</code> 换成对应的用户名即可。</p>
<p>将用户添加到 <code>docker</code> 组，可以避免 <code>root</code> 权限误操作的问题，但是由于 <code>dockerd</code> 引擎是运行在 <code>root</code> 用户下的，而 <code>docker</code> 组成员有权限指挥 <code>dockerd</code> 引擎来做很多事情，因此，该用户实际上是拥有了 <code>root</code> 的权限的。因此不要误解了将当前用户加入 <code>docker</code> 组的初衷，这和赋予用户 <code>sudo</code> 权力是一样的，可不是说这个用户就没有 <code>root</code>权限了。这样做，只是不再需要使用<code>sudo</code>了，也降低了使用 <code>sudo</code>时误操作的可能。</p>
<p>此外，这里说的权限问题，全是指使用 <code>docker</code> 命令操作<code>本机</code> <code>dockerd</code> 引擎，也就是通过 <code>/var/run/docker.sock</code> 来操作 <code>dockerd</code> 引擎的事情，只有这种有之前说的权限类的问题。</p>
<p>而 <code>docker</code> 命令还可以操作<code>远程</code> <code>dockerd</code> 的引擎，也就是 <code>-H</code> 参数，或者 <code>DOCKER_HOST</code> 环境变量所指定的 <code>Docker</code> 主机。这种情况通讯走的是网络、HTTP，不会有权限问题。所以，如果不打算操作本机的 <code>dockerd</code> 引擎，则不需要将用户加入 <code>docker</code> 组，也是可以操作远程服务器的。</p>
<hr>
<h3 id="（自加）Docker的配置文件放在哪里，如何修改配置？"><a href="#（自加）Docker的配置文件放在哪里，如何修改配置？" class="headerlink" title="（自加）Docker的配置文件放在哪里，如何修改配置？"></a>（自加）Docker的配置文件放在哪里，如何修改配置？</h3><ul>
<li><code>Ubuntu</code>系统的配置文件是<code>/etc/default/docker</code>（如果出现该文件不存在的情况，重启或自己新建一个文件都可以解决）</li>
<li><code>Centos</code>系统的配置文件是<code>/etc/sysconfig/docker</code></li>
</ul>
<hr>
<h3 id="（自加）如何更改Docker的默认存储位置？"><a href="#（自加）如何更改Docker的默认存储位置？" class="headerlink" title="（自加）如何更改Docker的默认存储位置？"></a>（自加）如何更改Docker的默认存储位置？</h3><p><code>Docker</code>的默认存储位置是<code>/var/lib/docker</code>，如果希望将Docker的本地文件存储到其他分区，可以使用<code>linux软连接</code>的方式来完成。<br>先停止<code>docker</code>进程，将<code>/var/lib/docker</code>中的文件全部移动到新位置，将新位置软链接至<code>/var/lib/docker</code> ，启动<code>docker</code>服务即可</p>
<hr>
<h3 id="（自加）Cannot-connect-to-the-Docker-daemon-Is-‘docker-d’-running-on-this-host"><a href="#（自加）Cannot-connect-to-the-Docker-daemon-Is-‘docker-d’-running-on-this-host" class="headerlink" title="（自加）Cannot connect to the Docker daemon. Is ‘docker -d’ running on this host?"></a>（自加）Cannot connect to the Docker daemon. Is ‘docker -d’ running on this host?</h3><ol>
<li>看看进程是否起来：<code>ps aux|grep docker</code>  </li>
<li>是否是使用普通用户启动，使用<code>sudo</code>的方式来启动，或将用户加入<code>docker</code>用户组</li>
<li>然后看看报错日志：<code>docker -d</code> </li>
<li>如果报缺失库文件<code>libdevmapper.so.1.02</code>   ，进行安装：<code>yum install libdevmapper.so.1.02</code> 再次起服务：<code>service docker start</code> 查看进程：<code>ps aux|grep docker</code></li>
</ol>
<hr>
<h3 id="（自加）dockser安装好后如何验证是否安装正常？"><a href="#（自加）dockser安装好后如何验证是否安装正常？" class="headerlink" title="（自加）dockser安装好后如何验证是否安装正常？"></a>（自加）dockser安装好后如何验证是否安装正常？</h3><ol>
<li>拉取<code>hello-world</code>镜像来验证</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p>如果输出中有correct则说明正常</p>
<ol>
<li><p>测试是否可以正常退出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti centos /bin/bash</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试是否可以返回信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti centos echo &apos;hello world&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果崩溃或死机需要升级内核到<code>3.10.0</code>以上版本<br>使用<code>yum</code>来升级内核<code>http://www.tuicool.com/articles/rUvERv</code><br>再测试即可成功</p>
<hr>
<h3 id="（自加）因内核版本过低导致操作系统自动重启"><a href="#（自加）因内核版本过低导致操作系统自动重启" class="headerlink" title="（自加）因内核版本过低导致操作系统自动重启"></a>（自加）因内核版本过低导致操作系统自动重启</h3><p>官方推荐使用最低<code>3.10.X</code>版本内核，当然你也可以使用<code>2.6.X</code>版本安装，安装是可以安装上，但是在进行后续的操作时。比如：<code>run -ti</code> 进入到容器后再退出来，可能会造成操作系统宕机重启</p>
<hr>
<h3 id="（自加）当你的内核版本已经支持了，也正常安装了，但是进程一开启就挂掉？"><a href="#（自加）当你的内核版本已经支持了，也正常安装了，但是进程一开启就挂掉？" class="headerlink" title="（自加）当你的内核版本已经支持了，也正常安装了，但是进程一开启就挂掉？"></a>（自加）当你的内核版本已经支持了，也正常安装了，但是进程一开启就挂掉？</h3><p>答：你需要先<code>yum update</code>，先更新自己的操作系统。<br>这是官方推荐的三大步骤：</p>
<ol>
<li>查看内核版本：<code>3.10.X</code>以上 <code>uname -r</code></li>
<li>更新操作系统：<code>yum update</code>  </li>
<li>正式安装：（使用<code>yum</code>的方式安装，可能需要用到epel源）</li>
</ol>
<ul>
<li><code>centos6</code> 安装<code>docker-io</code> （<code>centos6</code>只支持到<code>1.7</code>版本）</li>
<li><code>centos7</code> 安装<code>docker-engine</code> （官方指定的<code>repo</code>中指定的是<code>centos7</code>）（注意最新版本命名不再是这2种，请查看官方的最新安装文档）</li>
</ul>
<hr>
<h3 id="服务器上线后，怎么发现总有个-xmrig-的容器在跑，删了还出来，这是什么鬼？"><a href="#服务器上线后，怎么发现总有个-xmrig-的容器在跑，删了还出来，这是什么鬼？" class="headerlink" title="服务器上线后，怎么发现总有个 xmrig 的容器在跑，删了还出来，这是什么鬼？"></a>服务器上线后，怎么发现总有个 xmrig 的容器在跑，删了还出来，这是什么鬼？</h3><blockquote>
<p><code>警告！！你的服务器已经被入侵了！！</code></p>
</blockquote>
<p> 有些人服务器上线后，发现突然多了一些莫名奇妙的容器在跑。比如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">IMAGE           COMMAND                  CREATED      STATUS                      PORTS    NAMES</span><br><span class="line">linuxrun/cpu2   &quot;./xmrig --algo=cr....&quot;  4 hours ago  Exited (137) 7 minutes ago           linuxrun-cpu2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这就是有人在你的 Docker 宿主上跑了一个 <code>xmrig</code> 挖矿的蠕虫，因为你的系统被<code>入侵了</code>……</p>
<p>在你大叫 <code>Docker</code> 不安全之前，<code>先检讨一下自己</code>是不是做错了。检查一下 <code>dockerd</code> 引擎是否配置错误：<code>ps -ef | grep dockerd</code>，如果你看到的是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep dockerd</span><br><span class="line">123  root   12:34   /usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure>
<p>如果在其中没有 <code>--tlsverify</code> 类的 <code>TLS</code> 配置参数，那就说明你将你的系统大门彻底敞开了。这是配置上<code>严重的安全事故</code>。</p>
<p><code>-H tcp://0.0.0.0:2375</code> 是说你希望通过 <code>2375/tcp</code> 来远程操控你的 <code>Docker</code> 引擎，但是如果你没有加 <code>--tlsverify</code> 类的配置，就表明你的意图是允许任何人来操控你的 <code>Docker</code> 引擎，而 <code>Docker</code> 引擎是以 <code>root</code> 权限允许的，因此，你等于给了地球上所有人你服务器的 <code>root</code> 权限，而且还<code>没密码</code>。</p>
<p>如果细心一些，去查看 <code>dockerd</code> 的服务日志，<code>journalctl -u docker</code>，日志中有明确的警告，警告你这么配置是极端危险的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -u docker</span><br><span class="line">...</span><br><span class="line">level=warning msg=&quot;[!] DON&apos;T BIND ON ANY IP ADDRESS WITHOUT setting --tlsverify IF YOU DON&apos;T KNOW WHAT YOU&apos;RE DOING [!]&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果这些你都忽略了，那么被别人入侵就太正常了，是你自己<code>邀请</code>别人来的。所以，Docker 服务绑定端口，<code>必须</code>通过 TLS 保护起来，以后见到 <code>-H tcp://....</code> 就要检查，是否同时配置了 <code>--tlsverify</code>，如果没看到，那就是严重错误了。</p>
<p>这也是为什么推荐使用 <code>docker-machine</code> 进行 <code>Docker</code> 宿主管理的原因，因为 <code>docker-machine</code> 会帮你创建证书、配置 TLS，确保服务器的安全。</p>
<blockquote>
<p>进一步如何配置 TLS 的信息，可以查看官网文档：<a href="https://docs.docker.com/engine/security/https/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/https/</a><br>关于 <code>docker-machine</code> 的介绍，可以看官网文档：<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="noopener">https://docs.docker.com/machine/overview/</a></p>
</blockquote>
<hr>
<h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><h3 id="怎么固定容器-IP-地址？每次重启容器都要变化-IP-地址怎么办？"><a href="#怎么固定容器-IP-地址？每次重启容器都要变化-IP-地址怎么办？" class="headerlink" title="怎么固定容器 IP 地址？每次重启容器都要变化 IP 地址怎么办？"></a>怎么固定容器 IP 地址？每次重启容器都要变化 IP 地址怎么办？</h3><p>一般情况是不需要指定容器 IP 地址的。这不是虚拟主机，而是容器。其地址是供容器间通讯的，容器间则不用 IP 直接通讯（而且要极力避免使用IP硬编码通信），而使用<code>容器名</code>、<code>服务名</code>、<code>网络别名</code>。</p>
<p>而要实现通过<code>容器名</code>、<code>服务名</code>、<code>网络别名</code>通信的方式，就需要实现<code>服务发现</code>,为了保持向后兼容，<code>docker run</code> 在不指定 <code>--network</code> 时，所在的网络是 <code>default bridge</code>（即NAT模式）在这个网络下，需要使用 <code>--link</code> 参数才可以让两个容器找到对方。</p>
<p><code>--link</code>实现的功能：</p>
<ul>
<li>实现服务发现，因为<code>--link</code>会在容器内添加<code>环境变量</code>与<code>写入hosts文件</code></li>
<li>避免IP地址硬编码，通过名称的方式来通信，这里要注意不使用<code>--link</code>默认情况下容器之间也是互通的，因为底层网络都是通的</li>
</ul>
<p>这是有局限性的，因为这个时候使用的是 <code>/etc/hosts</code> 静态文件来进行的解析，比如一个主机挂了后，重新启动IP可能会改变。虽然说这种改变Docker是可能更新<code>/etc/hosts</code>文件，但是这有诸多问题，可能会因为竞争冒险导致 <code>/etc/hosts</code> 文件损毁，也可能还在运行的容器在取得 <code>/etc/hosts</code> 的解析结果后，不再去监视该文件是否变动。种种原因都可能会导致旧的主机无法通过容器名访问到新的主机。</p>
<p>参考官网文档：<a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/</a></p>
<p>如果可能不要使用这种过时的方式，而是用下面说的自定义网络的方式。</p>
<p>而对于新的环境（Docker 1.10以上），应该给容器建立自定义网络，同一个自定义网络中，可以使用对方容器的容器名、服务名、网络别名来找到对方。这个时候帮助进行<code>服务发现的是Docker 内置的DNS</code>。所以，无论容器是否重启、更换IP，内置的DNS都能正确指定到对方的位置。</p>
<p>参考官网文档：<a href="https://docs.docker.com/engine/userguide/networking/work-with-networks/#linking-containers-in-user-defined-networks" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/work-with-networks/#linking-containers-in-user-defined-networks</a></p>
<p>建议参考一下我写的 LNMP 的例子：<br><a href="https://coding.net/u/twang2218/p/docker-lnmp/git" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git</a></p>
<hr>
<h3 id="如何修改容器的-etc-hosts-文件？"><a href="#如何修改容器的-etc-hosts-文件？" class="headerlink" title="如何修改容器的 /etc/hosts 文件？"></a>如何修改容器的 /etc/hosts 文件？</h3><p>容器内的 <code>/etc/hosts</code> 文件不应该被随意修改，如果必须添加主机名和 IP 地址映射关系，应该在 <code>docker run</code> 时使用 <code>--add-host</code> 参数，或者在 <code>docker-compose.yml</code> 中添加 <code>extra_hosts</code> 项。</p>
<p>不过在用之前，应该再考虑一下真的需要修改 <code>/etc/hosts</code> 么？如果只是为了容器间互相访问，应该建立自定义网络，并使用 Docker 内置的 DNS 服务。</p>
<p>可以参考一下我写的这个 LNMP 多容器互连的例子：<a href="https://coding.net/u/twang2218/p/docker-lnmp/git" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git</a></p>
<hr>
<h3 id="怎么映射宿主端口？Dockerfile-中的EXPOSE和-docker-run-p-有啥区别？"><a href="#怎么映射宿主端口？Dockerfile-中的EXPOSE和-docker-run-p-有啥区别？" class="headerlink" title="怎么映射宿主端口？Dockerfile 中的EXPOSE和 docker run -p 有啥区别？"></a>怎么映射宿主端口？Dockerfile 中的EXPOSE和 docker run -p 有啥区别？</h3><p>Docker中有两个概念，一个叫做 <code>EXPOSE</code> ，一个叫做 <code>PUBLISH</code> 。</p>
<ul>
<li><code>EXPOSE</code> 是镜像/容器声明要暴露该端口，可以供其他容器使用。这种声明，在没有设定 <code>--icc=false</code>的时候，实际上只是一种<code>标注</code>，并不强制。也就是说，没有声明 <code>EXPOSE</code> 的端口，其它容器也可以访问。但是当强制 <code>--icc=false</code> 的时候，那么只有 <code>EXPOSE</code> 的端口，其它容器才可以访问。</li>
<li><code>PUBLISH</code> 则是通过映射宿主端口，将容器的端口公开于外界，也就是说宿主之外的机器，可以通过访问宿主IP及对应的该映射端口，访问到容器对应端口，从而使用容器服务。</li>
</ul>
<p><code>EXPOSE</code> 的端口可以不 <code>PUBLISH</code>，这样只有容器间可以访问，宿主之外无法访问。<br><code>PUBLISH</code> 的端口可以不事先 <code>EXPOSE</code>，换句话说 <code>PUBLISH</code> 等于同时隐式定义了该端口要 <code>EXPOSE</code>。</p>
<p><code>docker run</code> 命令中的 <code>-p</code>, <code>-P</code> 参数，以及 <code>docker-compose.yml</code> 中的  <code>ports</code> 部分，实际上均是指 <code>PUBLISH</code>。</p>
<p>小写 <code>-p</code> 是端口映射，格式为 <code>[宿主IP:]&lt;宿主端口&gt;:&lt;容器端口&gt;</code>，其中宿主端口和容器端口，既可以是一个数字，也可以是一个范围，比如：<code>1000-2000:1000-2000</code>。对于多宿主的机器，可以指定宿主IP，不指定宿主IP时，守护所有接口。</p>
<p>大写 <code>-P</code> 则是自动映射，将所有定义 <code>EXPOSE</code> 的端口，随机映射到宿主的某个端口。</p>
<hr>
<h3 id="我要映射好几百个端口，难道要一个个-p-么？"><a href="#我要映射好几百个端口，难道要一个个-p-么？" class="headerlink" title="我要映射好几百个端口，难道要一个个 -p 么？"></a>我要映射好几百个端口，难道要一个个 -p 么？</h3><p><code>-p</code> 是可以用范围的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 8001-8010:8001-8010</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="为什么-p-后还是无法通过映射端口访问容器里面的服务？"><a href="#为什么-p-后还是无法通过映射端口访问容器里面的服务？" class="headerlink" title="为什么 -p 后还是无法通过映射端口访问容器里面的服务？"></a>为什么 -p 后还是无法通过映射端口访问容器里面的服务？</h3><p>首先，当然是检查这个 <code>docker</code> 的容器是否启动正常： <code>docker ps</code>、<code>docker top &lt;容器ID&gt;</code>、<code>docker logs &lt;容器ID&gt;</code>、<code>docker exec -it &lt;容器ID&gt; bash</code>等，这是比较常用的排障的命令；如果是 <code>docker-compose</code> 也有其对应的这一组命令，所以排障很容易。</p>
<p>如果确保服务一切正常，甚至在容器里，可以访问到这些服务，<code>docker ps</code> 也显示出了端口映射成功，那么就需要检查<code>防火墙</code>了。</p>
<h4 id="本机防火墙"><a href="#本机防火墙" class="headerlink" title="本机防火墙"></a>本机防火墙</h4><p>在 Docker 运行的系统上<code>不应该运行任何防火墙</code>……没错，说你呢，CentOS 的 <code>firewalld</code> 和 Ubuntu 的 <code>ufw</code> 同学。由于 Docker 使用 <code>iptables</code> 规则来进行网络数据流的控制，而那些防火墙总以为只有自己撰写 iptables，从而经常会导致 Docker 设置了一些规则，然后转眼就被 <code>firewalld</code> 或 <code>ufw</code> 给清了，特别是起、停防火墙服务的时候。从而导致 Docker 的网络从外界无法访问。</p>
<blockquote>
<p> 为了避免 <code>iptables</code> 的规则干扰，不要在运行 Docker 的服务器上，运行<code>任何防火墙</code>或配置自定义的 <code>iptables</code> 规则，<code>除非</code>你非常清楚你在做什么，并且知道会产生什么后果。另外，<code>关闭防火墙后，记得重启系统，至少是重启 Docker 服务。否则防火墙的起、停、刷新这类行为会导致清空 Docker 设置的网络规则，而导致容器内的网络无法和外部互联</code>。</p>
</blockquote>
<h4 id="边界防火墙"><a href="#边界防火墙" class="headerlink" title="边界防火墙"></a>边界防火墙</h4><p>如果你使用的是云服务器，那么除了本机防火墙外，云服务的服务商一般会提供边界防火墙服务，比如安全组、安全策略类的东西。有些服务器为了安全起见，默认只开通必需的 <code>22</code> 端口给 SSH 使用，而其它端口屏蔽。这也是可能导致远程访问服务器 <code>-p</code> 端口失败的原因之一。如果你发现你在服务器本地访问服务，比如 <code>curl localhost</code> 没有阻碍，但是远程访问该服务就连接失败的话，那么应该去检查云服务商的安全设置，是否忘记了开启所需的端口。</p>
<hr>
<h3 id="vethxxxx-这种虚拟网卡和容器的对应关系从哪里看？"><a href="#vethxxxx-这种虚拟网卡和容器的对应关系从哪里看？" class="headerlink" title="vethxxxx 这种虚拟网卡和容器的对应关系从哪里看？"></a>vethxxxx 这种虚拟网卡和容器的对应关系从哪里看？</h3><p><code>北京-ZZ-虾米</code>提供了一个好办法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                       DRIVER</span><br><span class="line">56f04389b8f0        dockerlnmp_backend         bridge</span><br><span class="line">094fcb269385        dockerlnmp_frontend        bridge</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>NETWORK ID</code>，然后运行 <code>ip a | grep veth</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip a | grep veth</span><br><span class="line">12: veth22996d2@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-56f04389b8f0 state UP group default</span><br><span class="line">14: veth34ace9a@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-56f04389b8f0 state UP group default</span><br><span class="line">16: veth0bb3771@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-56f04389b8f0 state UP group default</span><br><span class="line">22: veth399b874@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-094fcb269385 state UP group default</span><br><span class="line">24: vethf24a0a9@if23: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-094fcb269385 state UP group default</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>br-56f04389b8f0</code> 以及 <code>br-094fcb269385</code>，<code>br-</code> 后面的是上面的网络<code>id</code>，由此可以看出 <code>veth</code> 和 <code>Docker 网络</code>的对应关系，而容器都是连接到了某个Docker网络上的，从而就有了容器和 veth 的对应关系。</p>
<p>对于某个网络出现了多个 <code>veth</code> 的情况，可以观察 <code>veth22996d2@if11</code> 后面的<code>if11</code> 这部分，和容器内的 <code>ip addr</code>的结果，一般 <code>奇-偶</code>是一对。</p>
<hr>
<h3 id="如何让一个容器连接两个网络？"><a href="#如何让一个容器连接两个网络？" class="headerlink" title="如何让一个容器连接两个网络？"></a>如何让一个容器连接两个网络？</h3><p>如果是使用 <code>docker run</code>，那很不幸，<code>一次只可以连接一个网络</code>，因为 <code>docker run</code> 的 <code>--network</code> 参数只可以出现一次（<code>如果出现多次，最后的会覆盖之前的</code>）。不过容器运行后，可以用命令 <code>docker network connect</code> 连接多个网络。</p>
<p>假设我们创建了两个网络：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create mynet1</span><br><span class="line">$ docker network create mynet2</span><br></pre></td></tr></table></figure>
<p>然后，我们运行容器，并连接这两个网络。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name web --network mynet1 nginx</span><br><span class="line">$ docker network connect mynet2 web</span><br></pre></td></tr></table></figure>
<p>但是如果使用 <code>docker-compose</code> 那就没这个问题了。因为实际上，<code>Docker Remote API</code> 是支持一次性指定多个网络的，但是估计是命令行上不方便，所以 <code>docker run 限定为只可以一次连一个</code>。<code>docker-compose 直接就可以将服务的容器连入多个网络，没有问题</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">        image: nginx</span><br><span class="line">        networks:</span><br><span class="line">            - mynet1</span><br><span class="line">            - mynet2</span><br><span class="line">networks:</span><br><span class="line">    mynet1:</span><br><span class="line">    mynet2:</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Docker-多宿主网络怎么配置？"><a href="#Docker-多宿主网络怎么配置？" class="headerlink" title="Docker 多宿主网络怎么配置？"></a>Docker 多宿主网络怎么配置？</h3><p>Docker 跨节点容器网络互联，最通用的是使用 <code>overlay</code> 网络。</p>
<p><code>一代 Swarm</code> 已经不再使用，它要求使用 <code>overlay</code> 网络前先准备好<code>分布式键值库</code>，比如 <code>etcd</code>,<code>consul</code> 或 <code>zookeeper</code>。然后在每个节点的 Docker 引擎中，配置<code>--cluster-store</code> 和 <code>--cluster-advertise</code> 参数。这样才可以互连。可以参考我写的 LNMP 容器互联例子中的 <a href="https://coding.net/u/twang2218/p/docker-lnmp/git/blob/master/run1.sh" target="_blank" rel="noopener">run1.sh</a> 这个脚本，这个脚本是利用 <code>docker-machine</code>自动建立 <code>Swarm</code> 并且配置好 <code>overlay</code> 的脚本，可以分析其流程。</p>
<p>现在都在使用<code>二代 Swarm</code>，也就是 <code>Docker Swarm Mode</code>，非常简单，只要 <code>docker swarm init</code> 建立集群，其它节点 <code>docker swarm join</code> 加入集群后，集群内的服务就自动建立了 <code>overlay</code> 网络互联能力。</p>
<p>需要注意的是，如果是<code>多网卡环境</code>，无论是 <code>docker swarm init</code> 还是 <code>docker swarm join</code>，都不要忘记使用参数 <code>--advertise-addr</code> 指定宣告地址，否则自动选择的地址很可能不是你期望的，从而导致集群互联失败。格式为 <code>--advertise-addr &lt;地址&gt;:&lt;端口&gt;</code>，地址可以是 <code>IP 地址</code>，也可以是<code>网卡接口</code>，比如 <code>eth0</code>。<code>端口默认为 2377</code>，如果不改动可以忽略。</p>
<p>此外，这是供<code>服务</code>使用的 <code>overlay</code>，因此所有 <code>docker service create</code> 的服务容器可以使用该网络，而 <code>docker run 不可以使用该网络</code>，除非明确该网络为 <code>--attachable</code>。</p>
<p>关于 <code>overlay</code> 网络的进一步信息，可以参考官网文档：<a href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/get-started-overlay/</a></p>
<p>虽然默认使用的是 <code>overlay</code> 网络，但这并不是唯一的多宿主互联方案。Docker 内置了一些其它的互联方案，比如<code>效率比较高的 macvlan</code>。如果在局域网络环境下，对 overlay 的额外开销不满意，那么可以考虑 <code>macvlan</code> 以及 <code>ipvlan</code>，这是比较好的方案。<br><a href="https://docs.docker.com/engine/userguide/networking/get-started-macvlan/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/get-started-macvlan/</a></p>
<p>此外，还有很多<code>第三方的网络方案</code>可以用来进行跨宿主互联，可以访问官网对应文档进一步查看：<a href="https://docs.docker.com/engine/extend/legacy_plugins/#/network-plugins" target="_blank" rel="noopener">https://docs.docker.com/engine/extend/legacy_plugins/#/network-plugins</a></p>
<hr>
<h3 id="明明-docker-network-ls-中看到了建立的-overlay-网络，怎么-docker-run-还说网络不存在？"><a href="#明明-docker-network-ls-中看到了建立的-overlay-网络，怎么-docker-run-还说网络不存在？" class="headerlink" title="明明 docker network ls 中看到了建立的 overlay 网络，怎么 docker run 还说网络不存在？"></a>明明 docker network ls 中看到了建立的 overlay 网络，怎么 docker run 还说网络不存在？</h3><p>如果在 <code>docker network ls</code> 中看到了如下的 <code>overlay</code> 网络：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">...</span><br><span class="line">24pz359114y0        mynet               overlay             swarm</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么这个名为 <code>mynet</code> 的网络是不可以连接到 <code>docker run</code> 的容器。如果试图连接则会出现报错。</p>
<p>如果是 <code>1.12</code> 的系统，会看到这样报错信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --network mynet busybox</span><br><span class="line">docker: Error response from daemon: network mynet not found.</span><br><span class="line">See &apos;docker run --help&apos;.</span><br></pre></td></tr></table></figure>
<p>报错说 <code>mynet</code> 网络找不到。其实如果仔细观察，会看到这个名为 <code>mynet</code> 的网络，驱动是 <code>overlay</code> 没有错，但它的 <code>Scope</code> 是 <code>swarm</code>。这个意思是说这个网络是在二代 <code>Swarm</code> 环境中建立的 <code>overlay</code> 网络，因此只可以由 <code>Swarm</code> 环境下的服务容器才可以使用。而 <code>docker run</code> 所运行的只是零散的容器，并非 <code>Service</code>，因此自然在零散容器所能使用的网络中，不存在叫 <code>mynet</code> 网络。</p>
<p><code>docker run</code> 可以使用的 <code>overlay</code> 网络是 <code>Scope</code> 为 <code>global</code> 的 <code>overlay</code> 网络，也就是<code>使用外置键值库所建立的 overlay 网络</code>，比如<code>一代 Swarm 的 overlay 网络</code>。</p>
<p>这点在 <code>1.13</code> 后稍有变化。如果是 <code>1.13</code> 以后的系统，会看到这样的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --network mynet busybox</span><br><span class="line">docker: Error response from daemon: Could not attach to network mynet: rpc error: code = 7</span><br><span class="line"> desc = network mynet not manually attachable.</span><br></pre></td></tr></table></figure>
<p>报错信息不再说网络找不到，而是说这个 <code>mynet</code> 网络无法连接。这是由于从 <code>1.13</code> 开始，允许在建立网络的时候声明这个网络是否可以被零散的容器所连接。如果 <code>docker network create</code> 加了 <code>--attachable</code> 的参数，那么在后期，这个网络是可以被普通容器所连接的。</p>
<p>但是这是在安全模型上开了一个口子，因此，默认不允许普通容器链接，并且不建议使用。</p>
<hr>
<h3 id="使用-Swarm-Mode-时，看到有个叫-ingress-的-overlay-网络，它和自己创建的网络有什么区别？"><a href="#使用-Swarm-Mode-时，看到有个叫-ingress-的-overlay-网络，它和自己创建的网络有什么区别？" class="headerlink" title="使用 Swarm Mode 时，看到有个叫 ingress 的 overlay 网络，它和自己创建的网络有什么区别？"></a>使用 Swarm Mode 时，看到有个叫 ingress 的 overlay 网络，它和自己创建的网络有什么区别？</h3><p>在启用了二代 Swarm 后，可能会在网络列表时看到一个名为 <code>ingress</code> 的 overlay 网络。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">6beb824623a4        bridge              bridge              local</span><br><span class="line">f3f636574c7a        docker_gwbridge     bridge              local</span><br><span class="line">cfeb2513a4a3        host                host                local</span><br><span class="line">88smbt683r5p        ingress             overlay             swarm</span><br><span class="line">24pz359114y0        mynet               overlay             swarm</span><br><span class="line">d35d69ece740        none                null                local</span><br></pre></td></tr></table></figure>
<p>这里可以看到两个 <code>overlay</code> 网络，其中一个是我们创建的 <code>mynet</code>，另一个则是 <code>Docker</code> 引擎自己创建的 <code>ingress</code>，从驱动和 <code>Scope</code> 可以看出两个网络都是给 <code>Swarm Mode</code> 使用的 <code>overlay</code> 网络。</p>
<p><code>ingress</code> 是 <code>overlay</code> 网络，但并不是普通的 <code>overlay network</code>，它是<code>为边界进入流量特殊准备的网络</code>。这个<code>网络存在于集群中每一个Docker宿主上，不需要额外建立</code>。</p>
<p>当我们使用 <code>docker service create -p 80:80</code> 这种形式创建一个服务的时候，我们要求映射集群端口 <code>80</code> 到服务容器的 <code>80</code> 端口上。其效果是访问任一节点的 <code>80</code> 端口，即使这个节点没有运行我们所需的容器，依旧可以连接到容器服务，并且取得结果。实现这样效果的一个原因就是因为 <code>ingress</code> 网络的存在。</p>
<p>Swarm 中的每个节点，都会有一个<code>隐藏的沙箱容器</code>监听宿主的服务端口，用于接收来自集群外界的访问。</p>
<p>我们可以通过 <code>docker network inspect ingress</code> 来看到这个沙箱容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker network inspect ingress</span><br><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">       &quot;Name&quot;: &quot;ingress&quot;,</span><br><span class="line">       &quot;Id&quot;: &quot;88smbt683r5p7c0l7sd0dpniw&quot;,</span><br><span class="line">       &quot;Scope&quot;: &quot;swarm&quot;,</span><br><span class="line">       &quot;Driver&quot;: &quot;overlay&quot;,</span><br><span class="line">       &quot;EnableIPv6&quot;: false,</span><br><span class="line">       &quot;IPAM&quot;: &#123;</span><br><span class="line">           &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">           &quot;Options&quot;: null,</span><br><span class="line">           &quot;Config&quot;: [</span><br><span class="line">               &#123;</span><br><span class="line">                   &quot;Subnet&quot;: &quot;10.255.0.0/16&quot;,</span><br><span class="line">                   &quot;Gateway&quot;: &quot;10.255.0.1&quot;</span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">       &quot;Internal&quot;: false,</span><br><span class="line">       &quot;Containers&quot;: &#123;</span><br><span class="line">           &quot;faff08692b5f916fcb15aa7ac6bc8633a0fa714a52a1fb75e57525c94581c45a&quot;: &#123;</span><br><span class="line">               &quot;Name&quot;: &quot;web.1.1jyunyva6picwsztzrj6t2cio&quot;,</span><br><span class="line">               &quot;EndpointID&quot;: &quot;58240770eb25565b472384731b1b90e36141a633ce184a5163829cf96e9d1195&quot;,</span><br><span class="line">               &quot;MacAddress&quot;: &quot;02:42:0a:ff:00:05&quot;,</span><br><span class="line">               &quot;IPv4Address&quot;: &quot;10.255.0.5/16&quot;,</span><br><span class="line">               &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">           &#125;,</span><br><span class="line">           &quot;ingress-sbox&quot;: &#123;</span><br><span class="line">               &quot;Name&quot;: &quot;ingress-endpoint&quot;,</span><br><span class="line">               &quot;EndpointID&quot;: &quot;fe8f89d4f99d7bacb14c5cb723682c180278d62e9edd10b523cdd81a45695c5d&quot;,</span><br><span class="line">               &quot;MacAddress&quot;: &quot;02:42:0a:ff:00:03&quot;,</span><br><span class="line">               &quot;IPv4Address&quot;: &quot;10.255.0.3/16&quot;,</span><br><span class="line">               &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &quot;Options&quot;: &#123;</span><br><span class="line">           &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;256&quot;</span><br><span class="line">       &#125;,</span><br><span class="line">       &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在上面的命令返回信息中，我们可以看到一个名为 <code>ingress-endpoint</code> 的容器，这就是<code>边界沙箱容器</code>。</p>
<p>当我们创建服务时，使用了 <code>-p</code> 参数后，服务容器就会被自动的加入到 <code>ingress</code> 网络中，同时会在沙箱中注册映射信息，告知哪个服务要求守护哪个端口，具体对应容器是哪些。</p>
<p>因此当沙箱收到外部连接后，通过访问端口就可以知道具体服务在守护，然后会通过这个 <code>ingress</code> 网络去将连接请求转发给对应服务容器。而由于 <code>ingress</code> 的本质是 <code>overlay network</code>，因此，无论服务容器运行于哪个节点上，沙箱都可以成功的将连接转发给正确的服务容器。</p>
<p>所以，<code>ingress</code> 是特殊用途的网络，只要服务有 <code>-p</code> 选项，那么服务容器就会自动被加入该网络。因此把 <code>ingress</code> 网络当做普通的 <code>overlay</code> 网络使用的话，除了会干扰 <code>Swarm</code> 正常的边界负载均衡的能力，也会破坏服务隔离的安全机制。所以不要把这个网络当做普通的 <code>overlay</code> 网络来使用，需要控制服务互联和隔离时，请用自行创建的 <code>overlay</code> 网络。</p>
<hr>
<h3 id="听说-–link-过时不再用了？那容器互联、服务发现怎么办？"><a href="#听说-–link-过时不再用了？那容器互联、服务发现怎么办？" class="headerlink" title="听说 –link 过时不再用了？那容器互联、服务发现怎么办？"></a>听说 –link 过时不再用了？那容器互联、服务发现怎么办？</h3><p>在 1-2 年前，<code>Docker</code> 所有容器都连接于默认的桥接网络上，也就是很多老文章鼓捣的 <code>docker0</code> 桥接网卡。因此实际上<code>默认情况下所有容器都是可以互联的（因为底层网络原本就是互通的，并不是说要link网络才通），没有隔离，当然这样安全性不好。</code>而服务发现，是在这种环境下发展出来的，通过修改容器内的 <code>/etc/hosts</code> 文件来完成的。凡是 <code>--link</code> 的主机的别名就会出现于 <code>/etc/hosts</code> 中，其地址由 <code>Docker</code> 引擎维护。因此容器间才可以通过<code>别名</code>互访。</p>
<p>但是这种办法并不是好的解决方案，<code>Docker</code> 早在一年多以前就已经使用自定义网络了。在同一个网络中的容器，可以互联，并且，<code>Docker</code> 内置了 <code>DNS</code>，容器内的应用可以使用<code>服务名</code>、<code>容器名</code>、<code>别名</code>来进行<code>服务发现</code>，<code>名称会经由内置的 DNS 进行解析，其结果是动态的；而不在同一网络中的容器，不可以互联</code>。</p>
<p>因此，现在早就不用 <code>--link</code> 了，而且非常不建议使用。</p>
<p>首先是因为使用 <code>--link</code> 就很可能还在用默认桥接网络，这很不安全，所有容器都没有适度隔离，用自定义网络才比较方便互联隔离。</p>
<p>其次，修改 <code>/etc/hosts</code> 文件有很多弊病。比如，高频繁的容器启停环境时，容易产生竞争冒险，导致 <code>/etc/hosts</code> 文件损坏，出现访问故障；或者有些应用发现是来自于 <code>/etc/hosts</code> 文件后，就假定其为静态文件，而缓存结果不再查询，从而导致容器启停 <code>IP</code> 变更后，使用旧的条目而无法连接到正确的容器等等。</p>
<p>另外，在一代 <code>Swarm</code> 环境中，在 <code>docker-compose.yml</code> 中使用了 <code>links</code> 就意味着服务间的强依赖关系，因此调度时不会将服务运行于不同节点，而是全部运行于一个节点，使得横向扩展失败。</p>
<p>所以不要再使用 <code>--link</code> 以及 <code>docker-compose.yml</code> 中的 <code>links</code> 了。应该使用 <code>docker network</code>，建立网络，而 <code>docker run --network</code> 来连接特定网络。或者使用 <code>version: &#39;2&#39;</code> 的 <code>docker-compose.yml</code> 直接定义自定义网络并使用。</p>
<p>实现：</p>
<ul>
<li>通过<code>名称</code>进行互联与服务发现，抛弃<code>ip</code>硬编码</li>
<li>通过<code>自定义网络network （内置DNS）</code>进行<code>动态</code>名称解析，抛弃<code>--link (修改容器hosts文件)</code>的<code>静态</code>名称解析</li>
<li><code>network</code>解决了安全隔离的问题，因为不同网络不会互联，而<code>--link</code>默认是可以互联</li>
<li><code>network</code>解决了<code>swarm</code>中的横向扩展，<code>--link</code>时强依赖的容器只能放在一起</li>
</ul>
<p>建议去看一下我写的 LNMP 多容器互联的例子：<a href="https://coding.net/u/twang2218/p/docker-lnmp/git" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git</a></p>
<hr>
<h3 id="使用-HBase-Hadoop-的时候，反向解析总是不对，怎么办？"><a href="#使用-HBase-Hadoop-的时候，反向解析总是不对，怎么办？" class="headerlink" title="使用 HBase/Hadoop 的时候，反向解析总是不对，怎么办？"></a>使用 HBase/Hadoop 的时候，反向解析总是不对，怎么办？</h3><p><code>Hadoop/HBase</code> 这类东西总喜欢根据设定的名称正向的解析一遍，然后在某个时候会反向的解析一遍检查是否一致。这种默认假定很多时候会出问题，特别是对于使用 <code>/etc/hosts</code> 的时候。正向解析会从 <code>/etc/hosts</code> 中取得，而反向解析则更可能走 <code>DNS</code>，于是出现了不一致。</p>
<p>对于 <code>Docker</code> 而言，使用自定义网络后，一个容器有很多个名字，内置 DNS 可以根据<code>服务名</code>、<code>容器名</code>、<code>网络别名</code>、<code>&lt;容器名&gt;.&lt;网络名&gt;</code> 等来进行解析。因此正向解析设置任何一个，其结果都会指向容器的 IP。</p>
<p>而反向解析则不会返回所有结果，而只返回<code>&lt;容器名&gt;.&lt;网络名&gt;</code>。</p>
<p>所以当有人这样运行容器的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span><br><span class="line">    --name wombat.example.com \</span><br><span class="line">    --hostname wombat.example.com \</span><br><span class="line">    --network net1 \</span><br><span class="line">    m3adow/nettools</span><br></pre></td></tr></table></figure>
<p>会发现反向解析结果并非自己所期望的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/ # ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">50: eth0@if51: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 02:42:ac:13:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.19.0.2/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:acff:fe13:2/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">/ # dig +short wombat.example.com</span><br><span class="line">172.19.0.2</span><br><span class="line">/ # host 172.19.0.2</span><br><span class="line">2.0.19.172.in-addr.arpa domain name pointer wombat.example.com.net1.</span><br></pre></td></tr></table></figure>
<p>从上面的解析结果可以看出来，由 <code>wombat.example.com</code> 正向解析的话，其结果是 <code>172.19.0.2</code>，确实是我们的 <code>IP</code> 地址；但是由 <code>172.19.0.2</code> 反向解析的话，所得到的域名确实 <code>wombat.example.com.net1</code>。多了一个 <code>.net1</code> 的尾巴。从而导致 <code>HBase/Hadoop</code> 这类软件出现故障。</p>
<p>解决办法很简单，我们现在知道反向域名解析的格式为 <code>&lt;容器名&gt;.&lt;网络名&gt;</code>。那么我们只需要<code>将网络名设为域名</code>就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create example.com</span><br><span class="line">$ docker run -it --rm \</span><br><span class="line">    --name wombat \</span><br><span class="line">    --hostname wombat.example.com \</span><br><span class="line">    --network example.com \</span><br><span class="line">    m3adow/nettools</span><br><span class="line">/ # ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">52: eth0@if53: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 02:42:ac:15:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.21.0.2/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:acff:fe15:2/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">/ # dig +short wombat.example.com</span><br><span class="line">172.21.0.2</span><br><span class="line">/ # host 172.21.0.2</span><br><span class="line">2.0.21.172.in-addr.arpa domain name pointer wombat.example.com.</span><br></pre></td></tr></table></figure>
<p>这里看到，正向解析没问题，反向解析也得到了 wombat.example.com 这个所期望的结果。</p>
<blockquote>
<p>需要注意的是，<code>服务名</code>、<code>主机名</code>、<code>容器名</code>、<code>网络名</code>这类可用于服务发现的名称，应该尽量使用 非 <code>FQDN</code>，也就是不包含 . 的单一名字，否则在某些情况下会出错。</p>
</blockquote>
<hr>
<h3 id="容器怎么取宿主机-IP-啊？"><a href="#容器怎么取宿主机-IP-啊？" class="headerlink" title="容器怎么取宿主机 IP 啊？"></a>容器怎么取宿主机 IP 啊？</h3><h4 id="单机环境"><a href="#单机环境" class="headerlink" title="单机环境"></a>单机环境</h4><p>如果是单机环境，很简单，不必琢磨怎么突破命名空间限制，<code>直接用环境变量送进去</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e HOST_IP=&lt;宿主的IP地址&gt; nginx</span><br></pre></td></tr></table></figure>
<p>然后容器内直接读取 <code>HOST_IP</code> 环境变量即可。</p>
<h4 id="集群环境"><a href="#集群环境" class="headerlink" title="集群环境"></a>集群环境</h4><p>集群环境相对比较复杂，<code>docker service create</code> 中的 <code>-e</code> 以及 <code>--env-file</code>是在服务创建时指定、读取环境变量内容，而不是运行时，因此对于每个节点都是一样的。而且目前不存在 <code>dockerd -e</code> 选项，所以直接使用这些选项达不到我们想要的效果。</p>
<p>不过有变通的办法，可以在宿主上建立一个 <code>/etc/variables</code> 文件（名字随意，这里用这个文件举例）。其内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST_IP=1.2.3.4</span><br></pre></td></tr></table></figure>
<p>其中 <code>1.2.3.4</code> 是这个节点的宿主 IP，因此每个节点的 <code>/etc/variables</code> 的内容不同。</p>
<p>而在启动服务时，指定挂载这个服务端本地文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name app \</span><br><span class="line">    --mount type=bind,source=/etc/variables,target=/etc/variables:ro \</span><br><span class="line">    myapp</span><br></pre></td></tr></table></figure>
<p>由于 <code>--mount</code> 是发生于容器运行时，因此所加载的是所运行的服务器的 <code>/etc/variables</code>，里面所包含的也是该服务器的 <code>IP</code> 地址。</p>
<p>在 <code>myapp</code> 这个镜像的入口脚本加入加载该环境变量文件的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/variables</span><br></pre></td></tr></table></figure>
<p>这样 <code>app</code> 这个服务容器就会拥有 <code>HOST_IP</code> 环境变量，其值为所运行的<code>宿主 IP</code>。</p>
<hr>
<h3 id="（自加）docker导致服务器不定时死机，网络连接不上"><a href="#（自加）docker导致服务器不定时死机，网络连接不上" class="headerlink" title="（自加）docker导致服务器不定时死机，网络连接不上"></a>（自加）docker导致服务器不定时死机，网络连接不上</h3><p>原因分析：可能因为你新建的网络，生成的新的随机命名的网桥设备以默认网关作为IP，导致与你的实际默认网关的IP造成IP冲突，所以导致网络每隔一段时间就连接不上。</p>
<p>创建网络：<code>docker network create xxx</code></p>
<p>值得注意的是，这个随机生成的网桥设备是不会出现在ubuntu系统的网络配置文件/etc/network/interface中的，它是作用于docker，也来源于docker,所以哪怕你用命令ifconfig br.xxxx down 再brctl brdel br.xxx也只是临时清除，当你重启操作系统后，因为docker开机启动，所以由docker而生成的br.xxx又会重新自动生成。所以只能使用删除网络命令：docker network rm xxx</p>
<p>排查过程：</p>
<ol>
<li>先ping 127.0.0.1</li>
<li>ping 容器IP</li>
<li>Ping本机IP，其它机器可Ping通断网的机器，也可以连接过去，说明局域网二层没有问题，主要问题是三层，即网关方面的问题，这就要使用arp -a来看网关是否使用对的IP与MAC地址</li>
<li>ping 网关—-如果到此步都是通的，说明网络错误主要来源于外部网络与网关这一段，查看是否本机有与网关冲突的可能</li>
<li>ping DNS—-网关IP冲突会导致DNS不可通</li>
</ol>
<p>查看ifconfig查看是否有多出一个网桥设备，查看该网桥设备的IP地址与实际使用该IP的MAC地址是否冲突，通过arp -a来验证。</p>
<hr>
<h3 id="（自加）如何删除docker0虚拟网桥"><a href="#（自加）如何删除docker0虚拟网桥" class="headerlink" title="（自加）如何删除docker0虚拟网桥"></a>（自加）如何删除docker0虚拟网桥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pkill Docker</span><br><span class="line">iptables -t nat -F</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">brctl delbr docker0</span><br><span class="line">重启Docker后解决</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（自加）创建docker容器后，在宿主机用“ip-netns-show”为何看不到容器的网络名字空间？"><a href="#（自加）创建docker容器后，在宿主机用“ip-netns-show”为何看不到容器的网络名字空间？" class="headerlink" title="（自加）创建docker容器后，在宿主机用“ip netns show”为何看不到容器的网络名字空间？"></a>（自加）创建docker容器后，在宿主机用“ip netns show”为何看不到容器的网络名字空间？</h3><p>docker在创建容器后，删除了/var/run/netns目录中的网络名字空间文件。因此，可以手动恢复它。<br>首先，使用下面的命令查看容器进程信息，比如这里的1234<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect --format=&apos;&#123;&#123;. State.Pid&#125;&#125;&apos; $container_id 1234</span><br></pre></td></tr></table></figure></p>
<p>接下来，在/proc目录下，把对应的网络名字空间文件链接到/var/run/netns目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /proc/1234/ns/net /var/run/netns/</span><br></pre></td></tr></table></figure></p>
<p>然后，就可以通过正常的系统命令来查看或操作容器的名字空间了。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns show</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="存储问题"><a href="#存储问题" class="headerlink" title="存储问题"></a>存储问题</h2><hr>
<h3 id="（自加）如何将一台宿主主机的docker环境迁移到另外一台宿主主机？"><a href="#（自加）如何将一台宿主主机的docker环境迁移到另外一台宿主主机？" class="headerlink" title="（自加）如何将一台宿主主机的docker环境迁移到另外一台宿主主机？"></a>（自加）如何将一台宿主主机的docker环境迁移到另外一台宿主主机？</h3><p>停止docker服务。将整个docker存储文件夹复制到另外一台宿主主机，然后调整另外一台宿主主机的配置即可</p>
<hr>
<h2 id="镜像问题"><a href="#镜像问题" class="headerlink" title="镜像问题"></a>镜像问题</h2><h3 id="docker-pull-下来的镜像文件都在哪？"><a href="#docker-pull-下来的镜像文件都在哪？" class="headerlink" title="docker pull 下来的镜像文件都在哪？"></a>docker pull 下来的镜像文件都在哪？</h3><blockquote>
<p>初学 Docker 要反复告诫自己，<code>Docker 不是虚拟机</code>。</p>
</blockquote>
<p>Docker不是虚拟机，Docker 镜像也不是虚拟机的 ISO 文件。Docker 的镜像是分层存储，每一个镜像都是由很多层，很多个文件组成。而<code>不同的镜像是共享相同的层的</code>，所以这是一个树形结构，不存在具体哪个文件是 <code>pull</code> 下来的镜像的问题。</p>
<p>具体镜像保存位置取决于系统，一般<code>Linux</code>系统下，在 <code>/var/lib/docker</code> 里。对于使用 <code>Union FS</code> 的系统(<code>Ubuntu</code>)，如 <code>aufs</code>, <code>overlay2</code> 等，可以直接在 <code>/var/lib/docker/{aufs,overlay2}</code> 下看到找到各个镜像的层、容器的层，以及其中的内容。</p>
<p>但是，对于<code>CentOS</code>这类没有<code>Union FS</code>的系统，会使用如<code>devicemapper</code>这类东西的一些特殊功能(如<code>snapshot</code>)模拟，镜像会存储于块设备里，因此无法看到具体每层信息以及每层里面的内容。</p>
<p>需要注意的是，默认情况下，<code>CentOS/RHEL</code> 使用 <code>lvm-loop</code>，也就是本地稀疏文件模拟块设备，这个文件会位于 <code>/var/lib/docker/devicemapper/devicemapper/data</code> 的位置。这是非常不推荐的，如果发现这个文件很大，那就说明你在用 <code>devicemapper + loop</code> 的方式，不要这么做，去参照官方文档，换 <code>direct-lvm</code>，也就是分配真正的块设备给 <code>devicemapper</code> 去用。</p>
<blockquote>
<p>与docker相关的本地资源都存放在/var/lib/docker目录下，其中container目录存放容器信息，graph目录镜像信息，aufs目录下存放具体的镜像层文件。</p>
</blockquote>
<hr>
<h3 id="docker-images-命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？"><a href="#docker-images-命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？" class="headerlink" title="docker images 命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？"></a>docker images 命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？</h3><p>这个显示的大小是计算后的大小，要知道 <code>docker image</code> 是分层存储的，在<code>1.10</code>之前，不同镜像无法共享同一层，所以基本上确实是下载大小。但是从<code>1.10</code>之后，已有的层（通过<code>SHA256</code>来判断），不需要再下载。<code>只需要下载变化的层</code>。所以实际下载大小比这个数值要小。而且本地硬盘空间占用，也比<code>docker images</code>列出来的东西加起来小很多，很多<code>重复的部分共享了</code>。</p>
<hr>
<h3 id="docker-images-a-后显示了好多-lt-none-gt-的镜像？都是什么呀？能删么？"><a href="#docker-images-a-后显示了好多-lt-none-gt-的镜像？都是什么呀？能删么？" class="headerlink" title="docker images -a 后显示了好多 &lt;none&gt; 的镜像？都是什么呀？能删么？"></a>docker images -a 后显示了好多 <code>&lt;none&gt;</code> 的镜像？都是什么呀？能删么？</h3><p>简单来说，<code>&lt;none&gt;</code> 就是说该镜像没有打标签。而没有打标签镜像一般分为两类：</p>
<ul>
<li>一类是<code>依赖镜像</code></li>
<li>一类是<code>丢了标签的镜像</code></li>
</ul>
<h4 id="依赖镜像"><a href="#依赖镜像" class="headerlink" title="依赖镜像"></a>依赖镜像</h4><p><code>Docker</code>的镜像、容器的存储层是<code>Union FS</code>，分层存储结构。所以任何镜像除了最上面一层打上标签(<code>tag</code>)外，其它下面依赖的一层层存储也是存在的。这些镜像没有打上任何标签，所以在 <code>docker images -a</code> 的时候会以 <code>&lt;none&gt;</code> 的形式显示。注意观察一下 <code>docker pull</code> 的每一层的<code>sha256</code>的校验值，然后对比一下 <code>&lt;none&gt;</code> 中的相同校验值的镜像，它们就是依赖镜像。这些镜像<code>不应当被删除</code>，因为有标签镜像在依赖它们。</p>
<h4 id="丢了标签的镜像"><a href="#丢了标签的镜像" class="headerlink" title="丢了标签的镜像"></a>丢了标签的镜像</h4><p>这类镜像可能本来有标签，后来丢了。原因可能很多，比如：</p>
<ul>
<li><code>docker pull</code> 了一个<code>同样标签但是新版本的镜像</code>，于是该标签从旧版本的镜像转移到了新版本镜像上，那么旧版本的镜像上的标签就丢了；</li>
<li><code>docker build</code> 时指定的标签都是一样的，那么<code>新构建的镜像拥有该标签</code>，而之前构建的镜像就丢失了标签。</li>
</ul>
<p>这类镜像被称为 <code>dangling</code> - <code>虚悬镜像</code>，这些镜像可以删除，使用 <code>dangling=true</code> 过滤条件即可</p>
<p>手动删除 dangling 镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -aq -f &quot;dangling=true&quot;)</span><br></pre></td></tr></table></figure>
<p>对于频繁构建的机器，比如 <code>Jenkins</code> 之类的环境。手动清理显然不是好的办法，应该定期执行固定脚本来清理这些无用的镜像。很幸运，<code>Spotify</code> 也面临了同样的问题，他们已经写了一个开源工具来做这件事情：<a href="https://github.com/spotify/docker-gc" target="_blank" rel="noopener">https://github.com/spotify/docker-gc</a></p>
<hr>
<h3 id="为什么-Docker-Hub-的镜像尺寸和-docker-images-不一致？"><a href="#为什么-Docker-Hub-的镜像尺寸和-docker-images-不一致？" class="headerlink" title="为什么 Docker Hub 的镜像尺寸和 docker images 不一致？"></a>为什么 Docker Hub 的镜像尺寸和 docker images 不一致？</h3><p><code>Docker Hub</code>上显示的是经过 <code>gzip压缩后的镜像大小</code>，这个大小也是你将下载的镜像大小，一般来说也是 <code>Docker Hub</code> 用户最关心的大小。</p>
<p>而 <code>docker images</code> 显示的是<code>pull</code>下来并<code>解压缩后的大小</code>，因为使用<code>docker images</code>的时候更关心的是本地磁盘空间占用的大小，所以这里显示的是未压缩镜像的大小。</p>
<hr>
<h3 id="docker-commit-怎么用啊？"><a href="#docker-commit-怎么用啊？" class="headerlink" title="docker commit 怎么用啊？"></a>docker commit 怎么用啊？</h3><p>简单的回答就是，不要用 <code>commit</code>，去写 <code>Dockerfile</code>。</p>
<blockquote>
<p>Docker 不是虚拟机。这句话要在学习 Docker 的过程中反复提醒自己。所以不要把虚拟机中的一些概念带过来。</p>
</blockquote>
<p><code>Docker</code> 提供了很好的 <code>Dockerfile</code> 的机制来帮助定制镜像，可以直接使用 <code>Shell</code> 命令，非常方便。而且，这样制作的镜像更加透明，也<code>容易维护</code>，在基础镜像升级后，可以简单地重新构建一下，就可以继承基础镜像的安全维护操作。</p>
<p>使用 <code>docker commit</code> 制作的镜像被称为<code>黑箱镜像</code>，换句话说，就是里面进行的是黑箱操作，除本人外无人知晓。即使这个制作镜像的人，过一段时间后也不会完整的记起里面的操作。那么当有些东西需要改变时，或者因基础镜像更新而需要重新制作镜像时，会让一切变得异常困难，就如同重新安装调试配置服务器一样，失去了 Docker 的优势了。</p>
<p>另外，<code>Docker</code> 不是虚拟机，其文件系统是 <code>Union FS</code>，<code>分层式存储</code>，每一次 <code>commit</code> 都会建立一层，上一层的文件并不会因为 <code>rm</code> 而删除，<code>只是在当前层标记为删除而看不到了而已</code>，每次 <code>docker pull</code> 的时候，<code>那些不必要的文件都会如影随形，所得到的镜像也必然臃肿不堪</code>。而且，<code>随着文件层数的增加，不仅仅镜像更臃肿，其运行时性能也必然会受到影响</code>。这一切都违背了 Docker 的最佳实践。</p>
<p>使用 <code>commit</code> 的场合是一些特殊环境，比如<code>入侵后保存现场</code>等等，这个命令<code>不应该成为定制镜像的标准做法</code>。所以，<code>请用 Dockerfile 定制镜像</code>。</p>
<hr>
<h3 id="为什么说不要使用-import-export-save-load-commit-来构建镜像？"><a href="#为什么说不要使用-import-export-save-load-commit-来构建镜像？" class="headerlink" title="为什么说不要使用 import, export, save, load, commit 来构建镜像？"></a>为什么说不要使用 import, export, save, load, commit 来构建镜像？</h3><p><code>commit</code> 命令在前一个问答已经说过，这是制作<code>黑箱镜像</code>，无法维护，不应该被使用。</p>
<p><code>import</code> 和 <code>export</code> 的做法，实际上是<code>将一个容器来保存为 tar 文件，然后在导入为镜像</code>。<code>这样制作的镜像同样是黑箱镜像，不应该使用</code>。而且这类<code>导入导出会导致原有分层丢失，合并为一层，而且会丢失很多相关镜像元数据或者配置</code>，比如 CMD 命令就可能丢失，导致镜像无法直接启动。</p>
<p><code>save</code> 和 <code>load</code> 确实是镜像保存和加载，但是这是在没有 <code>registry</code> 的情况下，手动把镜像拷来拷去，这是回到了十多年的 <code>U 盘时代</code>。这同样是不推荐的，镜像的发布、更新维护应该使用 <code>registry</code>。无论是自己架设私有 <code>registry</code> 服务，还是使用公有 <code>registry</code> 服务，如 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>。</p>
<hr>
<h3 id="Dockerfile-怎么写？"><a href="#Dockerfile-怎么写？" class="headerlink" title="Dockerfile 怎么写？"></a>Dockerfile 怎么写？</h3><p>最直接也是最简单的办法是看官方文档。</p>
<p>这篇文章讲述具体 <code>Dockerfile</code> 的命令语法：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p>
<p>然后，学习一下官方的 <code>Dockerfile</code> 最佳实践：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></p>
<p>最后，去 <code>Docker Hub</code> 学习那些<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">官方(Official)镜像</a> <code>Dockerfile</code> 咋写的。</p>
<blockquote>
<p>提示：在写Dockerfile前先进行预先操作，把需要操作的命令记录下来，再整理编排</p>
</blockquote>
<hr>
<h3 id="Dockerfile-就是-shell-脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。"><a href="#Dockerfile-就是-shell-脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。" class="headerlink" title="Dockerfile 就是 shell 脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。"></a>Dockerfile 就是 shell 脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。</h3><p>不是这样的。</p>
<blockquote>
<p><code>Dockerfile</code> 不等于 <code>.sh</code> 脚本</p>
</blockquote>
<p><code>Dockerfile</code> 确实是描述如何构建镜像的，其中也提供了 <code>RUN</code> 这样的命令，可以运行 <code>shell</code> 命令。但是和普通 <code>shell</code> 脚本还有很大的不同。</p>
<p><code>Dockerfile</code> 描述的实际上是<code>镜像的每一层要如何构建</code>，所以每一个<code>RUN</code>是一个独立的一层。所以一定要理解“<code>分层存储</code>”的概念。<code>上一层的东西不会被物理删除，而是会保留给下一层，下一层中可以指定删除这部分内容，但实际上只是这一层做的某个标记，说这个路径的东西删了。但实际上并不会去修改上一层的东西</code>。每一层都是静态的，这也是容器本身的 <code>immutable</code> 特性，要保持自身的静态特性。</p>
<p>所以很多新手会常犯下面这样的错误，把 <code>Dockerfile</code> 当做 <code>shell</code> 脚本来写了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN yum update</span><br><span class="line">RUN yum -y install gcc</span><br><span class="line">RUN yum -y install python</span><br><span class="line">ADD jdk-xxxx.tar.gz /tmp</span><br><span class="line">RUN cd xxxx &amp;&amp; install</span><br><span class="line">RUN xxx &amp;&amp; configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>这是相当错误的。除了无畏的增加了很多层，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>
<p>正确的写法应该是把<code>同一个任务的命令</code>放到一个 <code>RUN</code> 下，多条命令应该用 <code>&amp;&amp;</code> 连接，并且在<code>最后要打扫干净</code>所使用的环境。比如下面这段摘自官方 <code>redis</code> 镜像 <code>Dockerfile</code> 的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</span><br><span class="line">    &amp;&amp; set -x \</span><br><span class="line">    &amp;&amp; apt-get update &amp;&amp; apt-get install -y $buildDeps --no-install-recommends \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;$REDIS_DOWNLOAD_URL&quot; \</span><br><span class="line">    &amp;&amp; echo &quot;$REDIS_DOWNLOAD_SHA1 *redis.tar.gz&quot; | sha1sum -c - \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="那我把所有命令都合并到一个-RUN-就对了吧？"><a href="#那我把所有命令都合并到一个-RUN-就对了吧？" class="headerlink" title="那我把所有命令都合并到一个 RUN 就对了吧？"></a>那我把所有命令都合并到一个 RUN 就对了吧？</h3><p>不是把所有命令都合为一个 <code>RUN</code>，要合理分层，以加快构建和部署。</p>
<blockquote>
<p>合理分层就是将具有<code>不同变更频繁程度</code>的层，进行拆分，让<code>稳定的部分在基础</code>，更<code>容易变更的部分在表层</code>，使得资源可以重复利用，以增加构建和部署的速度。</p>
</blockquote>
<p>以 <a href="https://coding.net/u/twang2218/p/docker-example/git/blob/master/node/Dockerfile" target="_blank" rel="noopener">node.js 的应用示例镜像</a>为例，其中的复制应用和安装依赖的部分，如果都合并一起，会写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY . /usr/src/app</span><br><span class="line">RUN npm install</span><br></pre></td></tr></table></figure>
<p>但是，在 <code>node.js</code> 应用镜像示例中，则是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br><span class="line">RUN npm install</span><br><span class="line">COPY . /usr/src/app</span><br></pre></td></tr></table></figure>
<p>从层数上看，确实多了一层。但实际上，这三行分开是故意这样做的，其目的就是合理分层，充分利用 Docker 分层存储的概念，以增加构建、部署的效率。</p>
<p>在 <code>docker build</code> 的构建过程中，<code>如果某层之前构建过，而且该层未发生改变的情况下，那么 docker 就会直接使用缓存，不会重复构建</code>。因此，<code>合理分层，充分利用缓存，会显著加速构建速度</code>。</p>
<p>第一行的目的是将 <code>package.json</code> 复制到应用目录，而不是整个应用代码目录。这样只有 <code>pakcage.json发生改变后，才会触发第二行 RUN npm install。而只要 package.json 没有变化，那么应用的代码改变就不会引发 npm install，只会引发第三行的 COPY . /usr/src/app，从而加快构建速度。</code></p>
<p>而如果按照前面所提到的，合并为两层，那么任何代码改变，都会触发 <code>RUN npm install</code>，从而浪费大量的带宽和时间。</p>
<p>合理分层除了可以加快构建外，还可以加快部署，要知道，<code>docker pull</code> 的时候，是分层下载的，并且<code>已存在的层就不会重复下载。</code></p>
<p>比如，这里的 <code>RUN npm install</code> 这一层，往往会几百 MB 甚至上 GB。而在 <code>package.json</code> 未发生变更的情况下，那么只有 <code>COPY . /usr/src/app</code> 这一层会被重新构建，并且也只有这一层会在各个节点 <code>docker pull</code> 的过程中重新下载，往往这一层的代码量只有几十 MB，甚至更小。这对于大规模的并行部署中，所节约的东西向流量是非常显著的。特别是敏捷开发环境中，<code>代码变更的频繁度要比依赖变更的频繁度高很多</code>，每次重复下载依赖，会导致不必要的流量和时间上的浪费。</p>
<hr>
<h3 id="context-到底是一个什么概念？"><a href="#context-到底是一个什么概念？" class="headerlink" title="context 到底是一个什么概念？"></a>context 到底是一个什么概念？</h3><p><code>context</code>，<code>上下文</code>，是 <code>docker build</code> 中很重要的一个概念。构建镜像必须指定 <code>context</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xxx &lt;context路径&gt;</span><br></pre></td></tr></table></figure>
<p>或者 <code>docker-compose.yml</code> 中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app:</span><br><span class="line">    build:</span><br><span class="line">        context: &lt;context路径&gt;</span><br><span class="line">        dockerfile: dockerfile</span><br></pre></td></tr></table></figure>
<p>这里都需要指定 <code>context</code>。</p>
<p><code>context 是工作目录</code>，但不要和构建镜像的<code>Dockerfile</code> 中的 <code>WORKDIR</code> 弄混，<code>context 是 docker build 命令的工作目录。</code></p>
<p><code>docker build</code> 命令实际上是客户端，真正构建镜像并非由该命令直接完成。<code>docker build</code> 命令将 <code>context</code> 的目录上传给 <code>Docker 引擎</code>，由它负责制作镜像。</p>
<p>在 <code>Dockerfile</code> 中如果写 <code>COPY ./package.json /app/</code> 这种命令，实际的意思并不是指执行 <code>docker build</code> 所在的目录下的 <code>package.json</code>，也不是指 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是指 <code>context</code> 目录下的 <code>package.json</code>。</p>
<p>这就是为什么有人发现 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为它们都在 <code>context</code> 之外，如果真正需要，应该将它们复制到 <code>context</code> 目录下再操作。</p>
<p>话说，有一些网文甚至搞笑的说要把 <code>Dockerfile</code> 放到磁盘根目录，才能构建如何如何。这都是对 <code>context</code> 完全不了解的表现。想象一下把整个磁盘<code>几十个 GB</code>当做上下文发送给 <code>dockerd</code> 引擎的情况。</p>
<p><code>docker build -t xxx .</code> 中的这个<code>.</code>，实际上<code>就是在指定 Context 的目录</code>，而<code>并非是指定 Dockerfile 所在目录</code>。</p>
<p>默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将 <code>Context</code> 下的名为 <code>Dockerfile</code> 的文件作为 <code>Dockerfile</code>。所以很多人会混淆，认为这个 <code>.</code> 是在说 <code>Dockerfile</code> 的位置，其实不然。</p>
<p>一般项目中，<code>Dockerfile</code> 可能被放置于两个位置。</p>
<ul>
<li>一个可能是放置于项目顶级目录，这样的好处是在顶级目录构建时，项目所有内容都在上下文内，方便构建；</li>
<li>另一个做法是，将所有 <code>Docker</code> 相关的内容集中于某个目录，比如 <code>docker</code> 目录，里面包含所有不同分支的 <code>Dockerfile</code>，以及 <code>docker-compose.yml</code> 类的文件、<code>entrypoint</code> 的脚本等等。这种情况的上下文所在目录不再是 <code>Dockerfile</code> 所在目录了，因此需要注意指定上下文的位置。</li>
</ul>
<p>此外，项目中可能会包含一些构建不需要的文件，这些文件不应该被发送给 <code>dockerd</code> 引擎，但是它们处于上下文目录下，这种情况，我们需要使用 <code>.dockerignore</code> 文件来过滤不必要的内容。<code>.dockerignore</code> 文件<code>应该放置于上下文顶级目录下，内容格式和 .gitignore 一样</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp</span><br><span class="line">db</span><br></pre></td></tr></table></figure>
<p>这样就过滤了 <code>tmp</code> 和 <code>db</code> 目录，它们不会被作为上下文的一部分发给 <code>dockerd</code> 引擎。</p>
<blockquote>
<p>如果你发现你的 <code>docker build</code> 需要发送庞大的 <code>Context</code> 的时候，就需要来检查是不是 <code>.dockerignore</code> 忘了撰写，或者忘了过滤某些东西了。</p>
</blockquote>
<hr>
<h3 id="ENTRYPOINT-和-CMD-到底有什么不同？"><a href="#ENTRYPOINT-和-CMD-到底有什么不同？" class="headerlink" title="ENTRYPOINT 和 CMD 到底有什么不同？"></a>ENTRYPOINT 和 CMD 到底有什么不同？</h3><p><code>Dockerfile</code> 的目的是制作镜像，换句话说，实际上是准备的是主进程运行环境。那么准备好后，需要执行一个程序才可以启动主进程，而启动的办法就是调用 <code>ENTRYPOINT</code>（接入点）并且把 <code>CMD</code> 作为参数传进去运行。也就是下面的概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT &quot;CMD&quot;</span><br></pre></td></tr></table></figure>
<p>假设有个 <code>myubuntu</code> 镜像 <code>ENTRYPOINT</code> 是 <code>sh -c</code>，而我们 <code>docker run -it myubuntu uname -a</code>。那么 <code>uname -a</code> 就是运行时指定的 <code>CMD</code>，那么 <code>Docker</code> 实际运行的就是结合起来的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;uname -a&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有指定 <code>ENTRYPOINT</code>，那么就只执行 <code>CMD</code>；</li>
<li>如果指定了 <code>ENTRYPOINT</code> 而没有指定 <code>CMD</code>，自然执行 <code>ENTRYPOINT</code>;</li>
<li>如果 <code>ENTRYPOINT</code> 和 <code>CMD</code> 都指定了，那么就如同上面所述，执行 <code>ENTRYPOINT &quot;CMD&quot;</code>；</li>
<li>如果没有指定 <code>ENTRYPOINT</code>，而 <code>CMD</code> 用的是上述那种 <code>shell</code> 命令的形式，则自动使用 <code>sh -c</code> 作为 <code>ENTRYPOINT</code>。</li>
</ul>
<p>注意最后一点的区别，这个区别导致了同样的命令放到 <code>CMD</code> 和 <code>ENTRYPOINT</code> 下效果不同，因此有可能放在 <code>ENTRYPOINT</code> 下的同样的命令，由于需要 <code>tty</code> 而运行时忘记了给（比如忘记了<code>docker-compose.yml</code> 的 <code>tty:true</code>）导致运行失败。</p>
<p>这种用法可以很灵活，比如我们做个 <code>git</code> 镜像，可以把 <code>git</code> 命令指定为 <code>ENTRYPOINT</code>，这样我们在 <code>docker run</code> 的时候，直接跟子命令即可。比如 <code>docker run git log</code> 就是显示日志。</p>
<hr>
<h3 id="拿到一个镜像，如何获得镜像的-Dockerfile-？"><a href="#拿到一个镜像，如何获得镜像的-Dockerfile-？" class="headerlink" title="拿到一个镜像，如何获得镜像的 Dockerfile ？"></a>拿到一个镜像，如何获得镜像的 Dockerfile ？</h3><ul>
<li>直接去 <code>Docker Hub</code> 上看：大多数 <code>Docker Hub</code> 上的镜像都会有 <code>Dockerfile</code>，直接在 <code>Docker Hub</code> 的镜像页面就可以看到 <code>Dockerfile</code> 的链接；</li>
<li>如果是自己公司做的，最简单的办法就是打个电话、发个消息问一下。别看这个说法看起来很傻，不少人都宁可自己琢磨也不去问；</li>
<li>如果没有 <code>Dockerfile</code>，一般这类镜像就不应该考虑使用了，这类黑箱似的镜像很容易有问题。如果是什么特殊原因，那继续往下看；</li>
<li><code>docker history</code> 可以看到镜像每一层的信息，包括命令，当然黑箱镜像的 <code>commit</code> 看不见操作；</li>
<li><code>docker inspect</code> 可以分析镜像很多细节。</li>
<li>直接运行镜像，进入<code>shell</code>，然后根据上面的分析结果去进一步分析日志、文件内容及变化。</li>
<li>经过分析后，自己写 <code>Dockerfile</code> 还原操作。</li>
</ul>
<hr>
<h3 id="在你的-LNMP-的例子中，PHP-的-Dockerfile-里面的-“构建依赖”-和-“运行依赖”-都是什么意思？"><a href="#在你的-LNMP-的例子中，PHP-的-Dockerfile-里面的-“构建依赖”-和-“运行依赖”-都是什么意思？" class="headerlink" title="在你的 LNMP 的例子中，PHP 的 Dockerfile 里面的 “构建依赖” 和 “运行依赖” 都是什么意思？"></a>在你的 LNMP 的例子中，PHP 的 Dockerfile 里面的 “构建依赖” 和 “运行依赖” 都是什么意思？</h3><p>这里所提到的是我的那个 <code>LNMP</code> 例子的 <code>php</code> 服务的 <code>Dockerfile</code>：<a href="https://coding.net/u/twang2218/p/docker-lnmp/git/blob/master/php/Dockerfile" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git/blob/master/php/Dockerfile</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">FROM php:7-fpm</span><br><span class="line">RUN set -xe \</span><br><span class="line"># &quot;构建依赖&quot;</span><br><span class="line">    &amp;&amp; buildDeps=&quot; \</span><br><span class="line">        build-essential \</span><br><span class="line">        php5-dev \</span><br><span class="line">        libfreetype6-dev \</span><br><span class="line">        libjpeg62-turbo-dev \</span><br><span class="line">        libmcrypt-dev \</span><br><span class="line">        libpng12-dev \</span><br><span class="line">    &quot; \</span><br><span class="line"># &quot;运行依赖&quot;</span><br><span class="line">    &amp;&amp; runtimeDeps=&quot; \</span><br><span class="line">        libfreetype6 \</span><br><span class="line">        libjpeg62-turbo \</span><br><span class="line">        libmcrypt4 \</span><br><span class="line">        libpng12-0 \</span><br><span class="line">    &quot; \</span><br><span class="line"># &quot;安装 php 以及编译构建组件所需包&quot;</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $&#123;runtimeDeps&#125; $&#123;buildDeps&#125; --no-install-recommends \</span><br><span class="line"># &quot;编译安装 php 组件&quot;</span><br><span class="line">    &amp;&amp; docker-php-ext-install iconv mcrypt mysqli pdo pdo_mysql zip \</span><br><span class="line">    &amp;&amp; docker-php-ext-configure gd \</span><br><span class="line">        --with-freetype-dir=/usr/include/ \</span><br><span class="line">        --with-jpeg-dir=/usr/include/ \</span><br><span class="line">    &amp;&amp; docker-php-ext-install gd \</span><br><span class="line"># &quot;清理&quot;</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove \</span><br><span class="line">        -o APT::AutoRemove::RecommendsImportant=false \</span><br><span class="line">        -o APT::AutoRemove::SuggestsImportant=false \</span><br><span class="line">        $buildDeps \</span><br><span class="line">    &amp;&amp; rm -rf /var/cache/apt/* \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure>
<p>这里是针对 <code>php</code> 镜像进行定制，默认情况下 <code>php:7-fpm</code> 中没有安装所需的 <code>mysqli</code>, <code>pdo_mysql</code>, <code>gd</code> 等组件，所以这里需要安装，而且，部分组件还需要编译。</p>
<p>因此，这里涉及了两类依赖库/工具，一类是安装、编译阶段所需要的依赖；另一类是运行时所需的依赖。要记住 <code>Dockerfile</code> 的最佳实践中<code>要求最终镜像只应该保留最小的所需依赖</code>，因此<code>安装构建的依赖应该在安装结束后清除</code>，这一层只<code>保留真正需要的运行时依赖</code>。</p>
<p>因此，遵循最佳实践的要求，这里区分了 <code>buildDeps</code> 和 <code>runtimeDeps</code> 后，可以在安装结束后，卸载、清理 <code>buildDeps</code> 的依赖。这样确保没有无关的东西还在该层中。</p>
<hr>
<h3 id="应用代码是应该挂载宿主目录还是放入镜像内？"><a href="#应用代码是应该挂载宿主目录还是放入镜像内？" class="headerlink" title="应用代码是应该挂载宿主目录还是放入镜像内？"></a>应用代码是应该挂载宿主目录还是放入镜像内？</h3><p>两种方法都可以。</p>
<p>如果代码变动<code>非常频繁</code>，比如开发阶段，代码几乎每几分钟就需要变动调试，这种情况可以使用 <code>--volume</code> 挂载宿主目录的办法。这样不用每次构建新镜像，直接再次运行就可以加载最新代码，甚至有些工具可以观察文件变化从而动态加载，这样可以提高开发效率。</p>
<p>如果代码<code>没有那么频繁变动</code>，比如发布阶段，这种情况，应该<code>将构建好的应用放入镜像</code>。一般来说是使用 <code>CI/CD</code> 工具，如 <code>Jenkins</code>, <code>Drone.io</code>, <code>Gitlab CI</code> 等，进行构建、测试、制作镜像、发布镜像、以及分步发布上线。</p>
<p>对于<code>配置文件</code>也是同样的道理，如果是<code>频繁变更的配置，可以挂载宿主，或者动态配置文件可以使用卷</code>。但是对于并<code>非频繁变更的配置文件，应该将其纳入版本控制中，走 CI/CD 流程进行部署</code>。</p>
<p>需要注意的一点是，<code>绑定宿主目录虽然方便，但是不利于集群部署，因为集群部署前还需要确保集群各个节点同步存在所挂载的目录及其内容。因此集群部署更倾向于将应用打入镜像，方便部署</code>。</p>
<hr>
<h3 id="为什么在-Dockerfile-中执行（导入-sql、service-xxx-start）不管用？"><a href="#为什么在-Dockerfile-中执行（导入-sql、service-xxx-start）不管用？" class="headerlink" title="为什么在 Dockerfile 中执行（导入 .sql、service xxx start）不管用？"></a>为什么在 Dockerfile 中执行（导入 .sql、service xxx start）不管用？</h3><p>这是典型的对 <code>Dockerfile</code> 以及镜像、容器的基本概念不了解。</p>
<blockquote>
<p><code>Dockerfile</code> 不是 <code>shell</code> 脚本，而是定制 <code>rootfs</code> 的脚本。<code>它并不是在运行时运行的，而是在构建时运行的</code>。</p>
</blockquote>
<p>导入 <code>.sql</code> 文件到数据库，实际上修改的是数据库数据文件，而数据库的数据文件存储于卷，默认为<code>匿名卷</code>，因此当导入行为结束后，<code>构建该层的容器停止运行，匿名卷被抛弃，所有导入行为都会丢失</code>，因此所谓的导入 <code>.sql</code> 的行为在 <code>Dockerfile</code> 里实际上完全没有意义。</p>
<p>而 <code>service xxxx start</code> 也完全没有意义，这是启动后台服务，且不说 <code>Docker</code> 中<code>不用后台服务</code>，这种启动行为对文件系统根本没影响，这仅仅是让后台在构建所用的容器中运行一下，完全没有意义。最后运行容器的时候，是另一个进程了，该没启动的东西还是不会启动。</p>
<p>但是不要因此就盲目的得出 <code>Dockerfile</code> 无法初始化数据库的结论。所有官方镜像都考虑到了定制的问题，去看特定官方镜像的文档，基本都会看到定制、初始化的方法。</p>
<p>比如官方 <code>mysql</code> 镜像中，可以把初始化的 <code>.sql</code> 脚本文件在 <code>Dockerfile</code> 中 <code>COPY</code> 至 <code>/docker-entrypoint-initdb.d/</code> 目录中，在容器第一次运行的时候，如果所挂载的卷是空的，那么就会依次<a href="https://github.com/docker-library/mysql/blob/4dd33136c4739667a223d39b6f829beb27b235cf/5.7/docker-entrypoint.sh#L151" target="_blank" rel="noopener">执行该目录中的文件</a>，从而完成数据库初始化、导入等功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM mysql:5.7</span><br><span class="line">COPY mysql-data-backup.sql /docker-entrypoint-initdb.d/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="为什么基于-Alpine-的镜像那么小？我可以都换成基于-Alpine-的镜像么？"><a href="#为什么基于-Alpine-的镜像那么小？我可以都换成基于-Alpine-的镜像么？" class="headerlink" title="为什么基于 Alpine 的镜像那么小？我可以都换成基于 Alpine 的镜像么？"></a>为什么基于 Alpine 的镜像那么小？我可以都换成基于 Alpine 的镜像么？</h3><p><code>Alpine Linux</code> 体积小是因为它所使用的基础命令来自精简的 <code>busybox</code>，并且它使用的是简化实现的 <code>musl</code> 作为库支持，而并非完整的 <code>glibc</code>。<code>musl</code> 体积小，但是有<code>可能有不兼容</code>的情况，因此一般不用 <code>Alpine</code> 的镜像，除非空间受限，体积大小很关键时才会使用。</p>
<p>过去出现过兼容问题，但是随着 <code>Docker</code> 的使用，对 <code>Alpine</code> 的需求会越来越多，更多的兼容问题会被发现、修复，所以相信在未来这应该是个不错的选择。但是如果现在就要使用，一定要进行重复的测试，确保没有会影响到自己的 <code>bug</code>。</p>
<hr>
<h3 id="可以看到镜像各层的依赖关系么？"><a href="#可以看到镜像各层的依赖关系么？" class="headerlink" title="可以看到镜像各层的依赖关系么？"></a>可以看到镜像各层的依赖关系么？</h3><p>镜像是分层存储的，镜像之间也可以依赖，因此利用 <code>Docker</code> 镜像很容易实现重复的部分复用。那么我们有没有办法可以可视化的看到镜像的依赖关系呢？</p>
<p>很早以前，<code>Docker</code> 有个 <code>docker images --tree</code> 的命令的，后来随着镜像分层平面化后，这个命令就取消了。幸运的是，Nate Jones 写了一个工具，用于可视化镜像分层依赖，叫做 <code>dockviz</code>：<a href="https://github.com/justone/dockviz" target="_blank" rel="noopener">https://github.com/justone/dockviz</a></p>
<p>对于 Mac 平台的用户，可以很方便的使用 <code>brew</code> 来进行安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install dockviz</span><br></pre></td></tr></table></figure>
<p>对于其它平台的用户，可以直接去<a href="https://github.com/justone/dockviz/releases" target="_blank" rel="noopener">发布页面</a>下载。</p>
<p>安装好后，直接执行 <code>dockviz images --tree</code> 即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ dockviz images --tree</span><br><span class="line">├─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│ └─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│   └─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│     └─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│       └─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│         └─&lt;missing&gt; Virtual Size: 108.3 MB</span><br><span class="line">│           └─&lt;missing&gt; Virtual Size: 108.3 MB</span><br><span class="line">│             └─&lt;missing&gt; Virtual Size: 108.3 MB</span><br><span class="line">│               └─&lt;missing&gt; Virtual Size: 108.3 MB</span><br><span class="line">│                 └─0b5dec81616c Virtual Size: 108.3 MB Tags: nginx:latest</span><br><span class="line">└─&lt;missing&gt; Virtual Size: 100.1 MB</span><br><span class="line">  └─&lt;missing&gt; Virtual Size: 100.1 MB</span><br><span class="line">    └─&lt;missing&gt; Virtual Size: 123.9 MB</span><br><span class="line">      └─&lt;missing&gt; Virtual Size: 131.2 MB</span><br><span class="line">        ├─&lt;missing&gt; Virtual Size: 272.8 MB</span><br><span class="line">        │ └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │   └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │     └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │       └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │         └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │           └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │             └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │               └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │                 └─&lt;missing&gt; Virtual Size: 737.9 MB</span><br><span class="line">        │                   └─4551430cfe80 Virtual Size: 738.3 MB Tags: openjdk:latest</span><br><span class="line">        └─&lt;missing&gt; Virtual Size: 132.4 MB</span><br><span class="line">          └─&lt;missing&gt; Virtual Size: 132.4 MB</span><br><span class="line">            └─&lt;missing&gt; Virtual Size: 132.4 MB</span><br><span class="line">...</span><br><span class="line">                            └─&lt;missing&gt; Virtual Size: 276.0 MB</span><br><span class="line">                                └─&lt;missing&gt; Virtual Size: 292.4 MB</span><br><span class="line">                                └─&lt;missing&gt; Virtual Size: 292.4 MB</span><br><span class="line">                                    └─&lt;missing&gt; Virtual Size: 292.4 MB</span><br><span class="line">                                    └─72d2be374029 Virtual Size: 292.4 MB Tags: tomcat:latest</span><br></pre></td></tr></table></figure>
<p>如果觉得文本格式太繁杂，也可以生成 <a href="https://en.wikipedia.org/wiki/DOT_%28graph_description_language" target="_blank" rel="noopener">DOT</a> 图)，使用命令 <code>dockviz images -d | dot -Tpng -o image_tree.png</code> 就可以将你的镜像依赖关系绘制成图（<a href="https://imagebin.ca/v/3ZhFvSPeqAi0）。" target="_blank" rel="noopener">https://imagebin.ca/v/3ZhFvSPeqAi0）。</a></p>
<hr>
<h3 id="（自加）如何批量清理临时镜像文件？"><a href="#（自加）如何批量清理临时镜像文件？" class="headerlink" title="（自加）如何批量清理临时镜像文件？"></a>（自加）如何批量清理临时镜像文件？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi $(sudo docker images -q -f dangling=true)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（自加）如何查看镜像支持的环境变量？"><a href="#（自加）如何查看镜像支持的环境变量？" class="headerlink" title="（自加）如何查看镜像支持的环境变量？"></a>（自加）如何查看镜像支持的环境变量？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run IMAGE env</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（自加）构建docker镜像应该遵循哪些原则？"><a href="#（自加）构建docker镜像应该遵循哪些原则？" class="headerlink" title="（自加）构建docker镜像应该遵循哪些原则？"></a>（自加）构建docker镜像应该遵循哪些原则？</h3><p>整体原则上，尽量保持镜像功能的明确和内容的精简，要点包括：</p>
<ul>
<li>尽量选取满足需求但较小的基础系统镜像，例如大部份时候可以选择<code>debian:wheezy</code>镜像，仅有<code>85MB</code>大小，或<code>alpine</code>、<code>busybox</code>等（注意这些精简镜像的库非完整库，可能造成应用不兼容等问题）。</li>
<li>清理编译生成文件、安装包的缓存等临时文件。</li>
<li>安装各个软件时要指定准确的版本号，并避免引入不需要的依赖</li>
<li>从安全角度考虑，应用要尽量使用系统的库和依赖</li>
<li>如果安装应用时需要配置一些特殊的环境变量，在安装后要还原不需要保持的变量值</li>
<li>使用<code>Dockerfile</code>创建镜像时要添加<code>.dockerignore</code>文件或使用干净的工作目录</li>
</ul>
<hr>
<h3 id="（自加）安装完成docker后使用docker-pull-NAME-拉取镜像时失败报错问题：dial-unix-var-run-docker-sock-no-such-file-or-directory"><a href="#（自加）安装完成docker后使用docker-pull-NAME-拉取镜像时失败报错问题：dial-unix-var-run-docker-sock-no-such-file-or-directory" class="headerlink" title="（自加）安装完成docker后使用docker pull NAME 拉取镜像时失败报错问题：dial unix /var/run/docker.sock: no such file or directory."></a>（自加）安装完成docker后使用<code>docker pull NAME</code> 拉取镜像时失败报错问题：<code>dial unix /var/run/docker.sock: no such file or directory.</code></h3><p>这是因为没有启动docker服务。使用<code>service docker start</code>启动即可。</p>
<hr>
<h3 id="（自加）docker做的ssh镜像，启动ssh服务时，提示Could-not-load-host-key-etc-ssh-ssh-host-rsa-key"><a href="#（自加）docker做的ssh镜像，启动ssh服务时，提示Could-not-load-host-key-etc-ssh-ssh-host-rsa-key" class="headerlink" title="（自加）docker做的ssh镜像，启动ssh服务时，提示Could not load host key: /etc/ssh/ssh_host_rsa_key"></a>（自加）docker做的ssh镜像，启动ssh服务时，提示Could not load host key: /etc/ssh/ssh_host_rsa_key</h3><p>在启用 ssh 服务时，有时会看到如下提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@bt:~# /etc/init.d/ssh start</span><br><span class="line">* Starting OpenBSD Secure Shell server sshd                                   </span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_dsa_key</span><br></pre></td></tr></table></figure>
<p>有两个提示 Could not load host key: /etc/ssh/ssh_host_rsa_key 和  Could not load host key: /etc/ssh/ssh_host_dsa_key ，此时如果从客户端连接到服务器时是不会成功的。其原因是在 SSH 连接协议中需要有 RSA 或 DSA 密钥的鉴权。 因此，我们可以在服务器端使用 ssh-keygen 程序来生成一对公钥/私钥对</p>
<p>运行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@bt:/etc/ssh# ssh-keygen -t rsa -b 2048 -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):            #直接回车即可</span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /etc/ssh/ssh_host_rsa_key.</span><br><span class="line">Your public key has been saved in /etc/ssh/ssh_host_rsa_key.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">3b:a4:b8:df:a9:15:d1:62:df:d5:d1:41:50:59:4a:96 root@bt</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|             .***|</span><br><span class="line">|         .   oE+o|</span><br><span class="line">|        + .   o .|</span><br><span class="line">|       . + . .   |</span><br><span class="line">|        S . .    |</span><br><span class="line">|     . o o       |</span><br><span class="line">|    . . +        |</span><br><span class="line">|     . o o       |</span><br><span class="line">|    ..o.o        |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<p>上面 ssh-keygen 命令中，-t 选项表示生成的密钥所使用的加密类型，这里选择的是 RSA ；-b 选项表示 bit，后接一个整数，表示加密的位数，该数值越大表示加密的强度越高；-f 选项后接要生成的密钥文件名。根据 /etc/ssh 目录下的 sshd_config 配置文件，RSA 密钥默认识别文件名为 ssh_host_rsa_key 。</p>
<p>命令执行成功后，在 /etc/ssh 下会看到有两个文件生成：ssh_host_rsa_key 和 ssh_host_rsa_key.pub ，前者是私钥，后者是公钥。这样，当再次用 putty 连接时，首先会提示服务器端的加密指纹已经被修改，如果信任则点 yes 继续，否则断开，这里当然是选择信任 yes 。此后，客户端将用公钥对数据进行加密后发往服务器，而服务器收到数据后则用私钥进行解密。</p>
<hr>
<h3 id="（自加）构建镜像时的构建层会被删除吗？"><a href="#（自加）构建镜像时的构建层会被删除吗？" class="headerlink" title="（自加）构建镜像时的构建层会被删除吗？"></a>（自加）构建镜像时的构建层会被删除吗？</h3><p>使用dockerfile创建自定义镜像，需要注意的是docker会自动删除中间临时创建的层，还需要注意的是构建过程中的每一步的操作和你所编写的Dockerfile中命令是一一对应的。</p>
<hr>
<h3 id="（自加）镜像会继承吗？"><a href="#（自加）镜像会继承吗？" class="headerlink" title="（自加）镜像会继承吗？"></a>（自加）镜像会继承吗？</h3><p>镜像会继承上一层镜像的功能，但是需要注意的是。</p>
<p>比如：你有一个拥有ssh功能的基础镜像，然后基于此ssh基础镜像构建出了一个apache镜像。<br>这时这个新构建出的镜像其实已经拥有两种功能，即ssh+apache功能，但是当我们尝试使用ssh登录到容器时，会发现无法登录。但是我们却可以通过-P映射出端口。这是为什么呢？其实，这并不是说没有继承ssh功能，而是因为我们没有启用ssh功能的原因。因此，当我们使用dockerfile构建镜像时，<code>会继承父镜像的开放端口，但却不会继承启动命令</code>。因此，需要在启动脚本中添加启动sshd的服务的命令。</p>
<hr>
<h3 id="（自加）构建镜像有commit和Dockerfile两种方式，推荐用哪种？为什么？"><a href="#（自加）构建镜像有commit和Dockerfile两种方式，推荐用哪种？为什么？" class="headerlink" title="（自加）构建镜像有commit和Dockerfile两种方式，推荐用哪种？为什么？"></a>（自加）构建镜像有commit和Dockerfile两种方式，推荐用哪种？为什么？</h3><p>建议以Dockerfile的方式来构建镜像，最好不要用commit，因为Dockerfile会比使用commit方式构建出的镜像更精简和方便多次修改，以构建出新的镜像，但我们可以先使用commit方式将部署应用的整个过程记录起来，方便写Dockerfile文件。</p>
<hr>
<h3 id="（自加）构建出的镜像体量太大，怎么精简点？"><a href="#（自加）构建出的镜像体量太大，怎么精简点？" class="headerlink" title="（自加）构建出的镜像体量太大，怎么精简点？"></a>（自加）构建出的镜像体量太大，怎么精简点？</h3><ul>
<li>Dockerfile关键字同类的最好写在一起，使用<code>&amp;&amp;</code> <code>\</code>的方式来将多个命令合在一起。</li>
<li>容器中的编译和缓存都要删除以节约体量</li>
</ul>
<hr>
<h3 id="（自加）使用Dockerfile构建镜像时，为优化镜像容量，是否可以使用-amp-amp-＼来减少关键字使用？"><a href="#（自加）使用Dockerfile构建镜像时，为优化镜像容量，是否可以使用-amp-amp-＼来减少关键字使用？" class="headerlink" title="（自加）使用Dockerfile构建镜像时，为优化镜像容量，是否可以使用&amp;&amp;　＼来减少关键字使用？"></a>（自加）使用Dockerfile构建镜像时，为优化镜像容量，是否可以使用<code>&amp;&amp;　＼</code>来减少关键字使用？</h3><p>使用<code>run</code>关键字时可以通过<code>&amp;&amp;＼</code>这种方式来把多行放在一起，但是在其它关键字时docker默认是不识别的，比如在<code>ADD</code>关键字中使用，就会报找不有带这个结尾的文件名。</p>
<hr>
<h3 id="（自加）构建镜像时，明明Dockerfile中所引用的内容作了更新，为什么docker-仍然使用原来的缓存，不进行更新呢？"><a href="#（自加）构建镜像时，明明Dockerfile中所引用的内容作了更新，为什么docker-仍然使用原来的缓存，不进行更新呢？" class="headerlink" title="（自加）构建镜像时，明明Dockerfile中所引用的内容作了更新，为什么docker 仍然使用原来的缓存，不进行更新呢？"></a>（自加）构建镜像时，明明Dockerfile中所引用的内容作了更新，为什么docker 仍然使用原来的缓存，不进行更新呢？</h3><p>必须牢记一个细节，那就是docker中的定义的内容更新一切以Dockerfile是否修改了为前提条件，只要你的Dockerfile没有作出修改，哪怕你的Dockerfile语句所引用的内容作了更新，docker依然只以Dockerfile的内容为依据，当有缓存可用时，依然使用缓存，而不会去使用Dockerfile中语句引用的更新内容。</p>
<p>比如：你的Dockerfile中写了一条wget从FTP下载内容的语句，你的Dockerfile没有修改，而FTP中新增加了一个文件，这时，docker会认为你的Dockerfile没有修改，所以仍然使用现有的镜像缓存数据，而不会去触发再次去FTP下载新的内容，这就导致你再次构建的镜像依然使用的是旧的内容，而不是FTP中新增加的内容</p>
<p>所以，docker的更新机制，要想更新，就只能修改Dockerfile，其它非Dockerfile的内容更新，只有使用<code>--no-cache=true</code>来强制docker重新生成新的引用缓存内容。</p>
<p>不过，<code>COPY</code>与<code>ADD</code>的操作会进行更新，不会使用缓存，所以我们可以将需要加入的新文件通过<code>COPY</code>与<code>ADD</code>的方式来添加，而不是在容器里下载，将你的想要放入容器的文件跟你的Dockerfile放在一起方便管理（无论本地或云端）</p>
<hr>
<h3 id="（自加）写Dockerfile可以加注释吗？"><a href="#（自加）写Dockerfile可以加注释吗？" class="headerlink" title="（自加）写Dockerfile可以加注释吗？"></a>（自加）写Dockerfile可以加注释吗？</h3><p>可以使用<code>#</code>来表示注释，但是需要注意的是，不能与命令处于同一行，否则会被docker误认为是构建命令。所以我们可以把注释放在构建命令的上面或下面来表示即可</p>
<hr>
<h3 id="（自加）为什么使用Dockerfile构建时明明下载到-tmp目录的文件，在构建的下一个语句时就没有了？"><a href="#（自加）为什么使用Dockerfile构建时明明下载到-tmp目录的文件，在构建的下一个语句时就没有了？" class="headerlink" title="（自加）为什么使用Dockerfile构建时明明下载到/tmp目录的文件，在构建的下一个语句时就没有了？"></a>（自加）为什么使用Dockerfile构建时明明下载到/tmp目录的文件，在构建的下一个语句时就没有了？</h3><p>这里需要了解docker使用的是AUFS文件系统，每一层都是独立的，上一层构建时的内容与下层无关。</p>
<p>由于/tmp目录是临时文件存放目录，而docker镜像是采用分层的结构，在进行dockerfile构建执行过程中，完成上一个构建命令，接着展开下一个构建命令时会自动把上一个命令的层给删除，这个删除操作中除了一些对系统有修改永久性安装或配置外的被保存外，其它如临时目录之类的都会自动被清空，还原为操作系统本来形态。所以就造成了下载后文件又不见的问题。<br>只要记住，<code>/tmp目录是一个特殊目录，它会在构建过程中每一层都会被清空，所以你只需要将下载的文件放在其它目录即可，就不会出现这个问题。</code></p>
<hr>
<h2 id="容器问题"><a href="#容器问题" class="headerlink" title="容器问题"></a>容器问题</h2><hr>
<h3 id="（自加）容器退出后，通过docker-ps-命令查看不到，数据会丢失吗？"><a href="#（自加）容器退出后，通过docker-ps-命令查看不到，数据会丢失吗？" class="headerlink" title="（自加）容器退出后，通过docker ps 命令查看不到，数据会丢失吗？"></a>（自加）容器退出后，通过docker ps 命令查看不到，数据会丢失吗？</h3><p>容器退出后会处于终止（EXITED）状态，此时可以通过docker ps -a查看。其中的数据也不会丢失，还是可以通过docker start 命令来启动它。只有删除容器才会清除所有数据。<br>另外，如果你将数据通过存储卷来存放，因为存储卷与网络一样都是置于docker文件系统之外的，所以哪怕容器被删除了，数据也不会丢失。</p>
<hr>
<h3 id="（自加）如何停止所有正在运行的容器？"><a href="#（自加）如何停止所有正在运行的容器？" class="headerlink" title="（自加）如何停止所有正在运行的容器？"></a>（自加）如何停止所有正在运行的容器？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker kill $(sudo docker ps -q)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（自加）如何清理批量所有容器？"><a href="#（自加）如何清理批量所有容器？" class="headerlink" title="（自加）如何清理批量所有容器？"></a>（自加）如何清理批量所有容器？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm $(sudo docker ps -qa)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（自加）如何给容器指定一个固定IP地址，而不是每次重启容器IP地址都会变？"><a href="#（自加）如何给容器指定一个固定IP地址，而不是每次重启容器IP地址都会变？" class="headerlink" title="（自加）如何给容器指定一个固定IP地址，而不是每次重启容器IP地址都会变？"></a>（自加）如何给容器指定一个固定IP地址，而不是每次重启容器IP地址都会变？</h3><p>使用pipework工具，不过不建议固执的纠结于IP地址硬编码，而是应该通过容器名、网络别名、服务名等方式来通信，因为docker内置了服务发现机制<code>--link</code>（变量+hosts文件）和<code>network</code>（变量+内置DNS）。</p>
<hr>
<h3 id="（自加）如何临时退出一个正在交互的容器的终端，而不终止它？"><a href="#（自加）如何临时退出一个正在交互的容器的终端，而不终止它？" class="headerlink" title="（自加）如何临时退出一个正在交互的容器的终端，而不终止它？"></a>（自加）如何临时退出一个正在交互的容器的终端，而不终止它？</h3><p>按<code>ctrl-p ctrl-q</code><br>如按<code>ctrl-c</code>往往会让容器内应用进程终止，进而会终止容器。</p>
<hr>
<h3 id="（自加）使用“docker-port”命令映射容器的端口时，系统报错Error：No-public-port-‘80’-published-for-e7d817698b6f，是什么意思？"><a href="#（自加）使用“docker-port”命令映射容器的端口时，系统报错Error：No-public-port-‘80’-published-for-e7d817698b6f，是什么意思？" class="headerlink" title="（自加）使用“docker port”命令映射容器的端口时，系统报错Error：No public port ‘80’ published for e7d817698b6f，是什么意思？"></a>（自加）使用“docker port”命令映射容器的端口时，系统报错Error：No public port ‘80’ published for e7d817698b6f，是什么意思？</h3><ul>
<li>创建镜像时Dockerfile要指定正确的EXPOSE的端口</li>
<li>容器启动时指定PublishAllPort=true</li>
</ul>
<hr>
<h3 id="（自加）可以在一个容器中同时运行多个应用进程吗？"><a href="#（自加）可以在一个容器中同时运行多个应用进程吗？" class="headerlink" title="（自加）可以在一个容器中同时运行多个应用进程吗？"></a>（自加）可以在一个容器中同时运行多个应用进程吗？</h3><p>一般不推荐在同一个容器内运行多个应用进程。如果有类似需求，有两种方法：</p>
<ul>
<li>可以通过一些额外的进程管理机制，如：supervisord，（不能用init/systemd，因为它们是完整的系统进程管理方案）</li>
<li>可以创建带while循环的shell脚本</li>
</ul>
<hr>
<h3 id="（自加）如何控制容器占用系统资源（CPU-内存）的份额？"><a href="#（自加）如何控制容器占用系统资源（CPU-内存）的份额？" class="headerlink" title="（自加）如何控制容器占用系统资源（CPU/内存）的份额？"></a>（自加）如何控制容器占用系统资源（CPU/内存）的份额？</h3><p>在使用docker create 命令创建容器或使用docker run 创建并启动容器的时候，可以使用</p>
<ul>
<li><code>-c</code> |<code>--cpu-share[=0]</code>参数来调整容器使用CPU的权重</li>
<li><code>-m</code>|<code>--memory[=MEMORY]</code>参数来调整容器使用内存的大小。</li>
</ul>
<hr>
<h3 id="（自加）容器中的文件系统是自身的吗？"><a href="#（自加）容器中的文件系统是自身的吗？" class="headerlink" title="（自加）容器中的文件系统是自身的吗？"></a>（自加）容器中的文件系统是自身的吗？</h3><p>容器中的文件系统是复用底层宿主机操作系统的内核与相关的系统库文件的。你会发现，它的uname -r查看到的是<code>复用底层主机操作系统的内核</code>。</p>
<h3 id="（自加）run容器时带不带cmd都可以吗？"><a href="#（自加）run容器时带不带cmd都可以吗？" class="headerlink" title="（自加）run容器时带不带cmd都可以吗？"></a>（自加）run容器时带不带cmd都可以吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid centos /bin/bash </span><br><span class="line">docker run -tid centos</span><br></pre></td></tr></table></figure>
<p>这两种情况，上面是带有CMD，下面是没有带CMD，这个CMD其实就是你创建镜像时在dockerfile中写的CMD，在你run启动一个容器时，如果你命令后面带有CMD，这样就忽略Dockerfile中定义的CMD，如果命令没写CMD(即<code>/bin/bash</code>)，它就会带上镜像默认的CMD在启动时运行定义的命令，直接输入的<code>/bin/bash</code>会在<code>docker ps -a</code>中的command中完整查看到，而dockerfile中定义的CMD，在run时看到的则是<code>sh -c &#39;CMD&#39;</code>的形式</p>
<hr>
<h3 id="（自加）run容器时，把宿主机上的文件通过-v挂载到容器了怎么没有？"><a href="#（自加）run容器时，把宿主机上的文件通过-v挂载到容器了怎么没有？" class="headerlink" title="（自加）run容器时，把宿主机上的文件通过-v挂载到容器了怎么没有？"></a>（自加）run容器时，把宿主机上的文件通过-v挂载到容器了怎么没有？</h3><p>在进行run时，一定要事先将需要的数据卷都挂载好 ，数据卷可以将本地的文件或目录挂载到容器，但默认是目录，所以如果是文件需要写清楚挂载到容器中的文件名，不可以只是写个目录名。而且对于一个镜像来说，通过dockerfile的方式构建出来的镜像，需要事先在dockerfile中通过VOLUMES来事先定义好哪些可以供挂载的目录，否则将来run时无法使用挂载数据卷到容器中。</p>
<hr>
<h3 id="（自加）挂载数据卷容器如果容器处于停止状态是否可用？"><a href="#（自加）挂载数据卷容器如果容器处于停止状态是否可用？" class="headerlink" title="（自加）挂载数据卷容器如果容器处于停止状态是否可用？"></a>（自加）挂载数据卷容器如果容器处于停止状态是否可用？</h3><p>数据卷容器中的挂载： </p>
<ul>
<li><p>当你创建了一个数据卷容器，然后创建另一个容器来<code>--volumes-from</code>的方式引用数据卷容器中的数据卷挂载信息，哪怕你要引用的数据卷容器已经exit，也仍然可以引用挂载信息成功，因为<code>数据卷是绕过容器文件系统之外的，只要容器没有删除，数据卷就会一直存在</code>，自然也就可以引用成功啦，无论是开还是关的状态<br>  即：使用<code>--volumes-from</code>参数所挂载数据卷的容器自身并不需要保持在运行状态</p>
</li>
<li><p>数据卷容器上的数据卷同步是双向的立刻同步，无论是普通容器关闭，数据卷容器打开，或者是数据卷容器关闭，普通容器打开，只要一开启，数据卷的挂载信息就会立刻同步</p>
</li>
</ul>
<hr>
<h3 id="（自加）容器中的数据如何实现迁移？"><a href="#（自加）容器中的数据如何实现迁移？" class="headerlink" title="（自加）容器中的数据如何实现迁移？"></a>（自加）容器中的数据如何实现迁移？</h3><p>由于数据卷和数据卷容器都是使用<code>双向同步</code>的机制，所以利用这一点可以进行数据迁移，不过需要注意的是，虽然可以利用同步将数据迁移到其它地方，而且某一个容器exit或sotp、rm了，也不影响其它节点的数据卷，因为毕竟是远程挂载的方式挂在容器中而已。<br>但是需要注意的一点是，由于是双向同步的，所以当你修改一点东西时，别的节点容器也会同步过来，所以这虽然实现了迁移，但是记住是双向同步的，所以将备份打包tar包后，当同步到本地然后将打包的备份移动到其它地方，容器中的对应的挂载数据卷中的内容也会被移除。</p>
<hr>
<h3 id="（自加）run运行容器时加不加-d的区别？"><a href="#（自加）run运行容器时加不加-d的区别？" class="headerlink" title="（自加）run运行容器时加不加-d的区别？"></a>（自加）run运行容器时加不加-d的区别？</h3><p>run创建运行容器时，不加选项默认是前台运行，加<code>-d</code>以后台守护进程模式运行。</p>
<hr>
<h3 id="（自加）run运行容器时，什么时候需要加-ti？"><a href="#（自加）run运行容器时，什么时候需要加-ti？" class="headerlink" title="（自加）run运行容器时，什么时候需要加-ti？"></a>（自加）run运行容器时，什么时候需要加-ti？</h3><p><code>-ti</code>是指以交互终端模式运行，因此，只要与<code>/bin/bash</code>或<code>exec</code>这些与终端相配合使用的都需要此选项。</p>
<hr>
<h3 id="（自加）对内服务是否一定要用–link才可以？"><a href="#（自加）对内服务是否一定要用–link才可以？" class="headerlink" title="（自加）对内服务是否一定要用–link才可以？"></a>（自加）对内服务是否一定要用–link才可以？</h3><p>对内服务可以通过–link的方式来实现域名关联（服务发现），而不用担心所关联的容器因为IP变动而无法连接的问题。（因此这里需要特别注意–link并不是说只有–link才可以与可ping通的容器关联上，而是说通过–link机制可以实现域名的关联，因此，只要底层网络是通的，就可以关联通信，使不使用–link都可以）</p>
<hr>
<h3 id="（自加）如何才能用容器外的设备来访问容器内的apache服务呢？"><a href="#（自加）如何才能用容器外的设备来访问容器内的apache服务呢？" class="headerlink" title="（自加）如何才能用容器外的设备来访问容器内的apache服务呢？"></a>（自加）如何才能用容器外的设备来访问容器内的apache服务呢？</h3><p>这个服务包括两部分：对内服务与对外服务<br>容器的网络连接方式有两种：</p>
<ul>
<li>一种是对外的端口映射方式，需要在run 创建运行容器时加上-P或-p 来提供对外端口来映射到容器内的端口，从而实现网络连接。但需要注意的是，如果以-ti参数来启动容器，是无法让外部的设备来访问的，如果要允许外部设备访问容器，需要使用-p参数对外映射端口。通常搭配-d（后台守护进程模式）-v（创建数据卷） 等参数一起使用。使用-ti参数启动的容器，更适合作为测试。</li>
<li>另一种是对内的容器Link互联机制，用于容器与容器之间的数据互联，如web与db，但这里再次澄清，并不是说只有使用–link才可以通信，而是–link会进行域名关联，从而避免所关联的容器的IP变动所导致的容器无法连接上，其实这一步只是在web容器的hosts文件中增加了一条到db的域名记录而已。说到底，只要网络是通的，就没有问题。</li>
</ul>
<hr>
<h3 id="（自加）容器中的的进程一定要前台运行吗？"><a href="#（自加）容器中的的进程一定要前台运行吗？" class="headerlink" title="（自加）容器中的的进程一定要前台运行吗？"></a>（自加）容器中的的进程一定要前台运行吗？</h3><p>不用。<br>容器中的进程按你平常是怎么运行就怎么运行即可，不用一定放在前台运行。<br>之所以我们看到的很多教程上都将比如apache、nginx放在前台运行，这是因为，而用superviosr等管理进程工具也将进程放在前台运行。这里隐藏了两个细节问题。</p>
<ol>
<li>单进程情况时，比如一个容器只运行一个apche或nginx进程时，它之所以是放在前台运行是因为为了避免容器EXIT</li>
<li>而在一个容器多进程的情况时，通过superviosr来管理时，是因为supervisor要求它所管理的进程必须放在前台的原因。</li>
</ol>
<p>因此，正是因为这两个原因，所以误导了我们，其实只要能保证容器不会EXIT，我们就可以将进程放在后台运行，正如正常所使用那样，我们可以通过while 循环的方式或进程管理器的方式来实现，这样哪怕是单个进程或多个进程都是可以放在后台运行的，不需要放在前台运行，因为怎么那个容器都不会EXIT的。</p>
<p>不过为了docker log 查看日志，而且遵循一个容器一个进程的原则，建议将应用放到前台运行，而不是后台。</p>
<hr>
<h3 id="（自加）使用commit方式构建将容器提交为镜像时需要停止吗？停止和不停止的区别是什么？"><a href="#（自加）使用commit方式构建将容器提交为镜像时需要停止吗？停止和不停止的区别是什么？" class="headerlink" title="（自加）使用commit方式构建将容器提交为镜像时需要停止吗？停止和不停止的区别是什么？"></a>（自加）使用commit方式构建将容器提交为镜像时需要停止吗？停止和不停止的区别是什么？</h3><p>使用commit方式提交容器状态来构建出镜像是指将你的容器的当前状态构建成镜像，因此可以根据你的需要将容器处于停止或运行中状态进行提交都可以。<br>但是需要注意的是，区别就是，正是因为commit是将你的容器的当前状态进行构建，而且docker是基于内存的，所以当你把你的容器stop掉后，那些在容器中运行时生效的配置当stop后，就会从内存中释放掉，因此，也就导致你把exit状态的容器构建成镜像时，可能并没有达到预期效果。因此，如果想把内存中的状态保存在镜像中，就一定不能stop容器，而是直接commit正在运行中的容器为镜像。</p>
<p>不过强烈建议不要使用commit来构建镜像，这样做出来的是黑箱镜像，不方便管理与维护</p>
<hr>
<h3 id="（自加）单个容器如何运行多个进程？"><a href="#（自加）单个容器如何运行多个进程？" class="headerlink" title="（自加）单个容器如何运行多个进程？"></a>（自加）单个容器如何运行多个进程？</h3><p>方式有三种：</p>
<ul>
<li>镜像继承（功能可以通过镜像继承，但需要注意的是将服务启动起来）</li>
<li>shell脚本（通过增加while循环加sleep的方式来达到容器不EXIT）</li>
<li>进程管理器（可以通过supervisor进程管理器来管理多进程，不过注意不能使用systemd这种完整系统的进程管理器）</li>
</ul>
<hr>
<h2 id="仓库问题"><a href="#仓库问题" class="headerlink" title="仓库问题"></a>仓库问题</h2><h3 id="（自加）仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？"><a href="#（自加）仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？" class="headerlink" title="（自加）仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？"></a>（自加）仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？</h3><p>首先，仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像。注册服务器是存放实际镜像文件的地方。注册索引则负责维护用户的账号、权限、搜索、标签等的管理。因此，注册服务器利用注册索引来实现认证等管理。</p>
<hr>
<h3 id="（自加）从非官方仓库下载镜像的时候，有时候会提示“Error-Invalid-registry-endpoint-……-”？"><a href="#（自加）从非官方仓库下载镜像的时候，有时候会提示“Error-Invalid-registry-endpoint-……-”？" class="headerlink" title="（自加）从非官方仓库下载镜像的时候，有时候会提示“Error:Invalid registry endpoint ……..”？"></a>（自加）从非官方仓库下载镜像的时候，有时候会提示“Error:Invalid registry endpoint ……..”？</h3><p>Docker自1.3.0版本往后，加强了对镜像安全性的验证，需要手动添加非官方仓库的信任。<br>编辑Docker配置文件，在其中添加如下内容并重启Docker服务即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;--insecure-registry xxxxxx:5000&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="（自加）registry有多少版本？"><a href="#（自加）registry有多少版本？" class="headerlink" title="（自加）registry有多少版本？"></a>（自加）registry有多少版本？</h3><ul>
<li>旧版本V1，V1的push会提示已将镜像上传到的目录</li>
<li>新版本V2，V2的push不会提示上传到了哪个目录，只是给出一串digital 数字码</li>
</ul>
<hr>
<h2 id="日志问题"><a href="#日志问题" class="headerlink" title="日志问题"></a>日志问题</h2><h3 id="Docker-日志都在哪里？怎么收集？"><a href="#Docker-日志都在哪里？怎么收集？" class="headerlink" title="Docker 日志都在哪里？怎么收集？"></a>Docker 日志都在哪里？怎么收集？</h3><p>日志分两类，一类是 <code>Docker 引擎日志</code>；另一类是 <code>容器日志</code>。</p>
<h4 id="Docker-引擎日志"><a href="#Docker-引擎日志" class="headerlink" title="Docker 引擎日志"></a>Docker 引擎日志</h4><p><code>Docker 引擎日志</code> 一般是交给了 <code>Upstart</code>(Ubuntu 14.04) 或者 <code>systemd</code> (CentOS 7, Ubuntu 16.04)。前者一般位于 <code>/var/log/upstart/docker.log</code> 下，后者一般通过 <code>jounarlctl -u docker</code> 来读取。不同系统的位置都不一样，SO上有人总结了一份列表，我修正了一下，可以参考：</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>日志位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ubuntu(14.04)</td>
<td>/var/log/upstart/docker.log</td>
</tr>
<tr>
<td>Ubuntu(16.04)</td>
<td>journalctl -u docker.service</td>
</tr>
<tr>
<td>CentOS 7/RHEL 7/Fedora</td>
<td>journalctl -u docker.service</td>
</tr>
<tr>
<td>CoreOS</td>
<td>journalctl -u docker.service</td>
</tr>
<tr>
<td>OpenSuSE</td>
<td>journalctl -u docker.service</td>
</tr>
<tr>
<td>OSX</td>
<td>~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/log/d‌​ocker.log</td>
</tr>
<tr>
<td>Debian GNU/Linux 7</td>
<td>/var/log/daemon.log</td>
</tr>
<tr>
<td>Debian GNU/Linux 8</td>
<td>journalctl -u docker.service</td>
</tr>
<tr>
<td>Boot2Docker</td>
<td>/var/log/docker.log</td>
</tr>
</tbody>
</table>
<h4 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h4><p>容器的日志 则可以通过 <code>docker logs</code> 命令来访问，而且可以像 <code>tail -f</code> 一样，使用 <code>docker logs -f</code> 来实时查看。如果使用 <code>Docker Compose</code>，则可以通过 <code>docker-compose logs &lt;服务名&gt;</code> 来查看。</p>
<p>如果深究其日志位置，每个容器的日志默认都会以 <code>json-file</code> 的格式存储于 <code>/var/lib/docker/containers/&lt;容器id&gt;/&lt;容器id&gt;-json.log</code> 下，不过并不建议去这里直接读取内容，因为 <code>Docker</code> 提供了更完善地日志收集方式 - <code>Docker 日志收集驱动</code>。</p>
<p>关于日志收集，<code>Docker</code> 内置了很多日志驱动，可以通过类似于 <code>fluentd</code>, <code>syslog</code> 这类服务收集日志。无论是 <code>Docker</code> 引擎，还是容器，都可以使用日志驱动。比如，如果打算用 <code>fluentd</code> 收集某个容器日志，可以这样启动容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    --log-driver=fluentd \</span><br><span class="line">    --log-opt fluentd-address=10.2.3.4:24224 \</span><br><span class="line">    --log-opt tag=&quot;docker.&#123;&#123;.Name&#125;&#125;&quot; \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure>
<p>其中 <code>10.2.3.4:24224</code> 是 <code>fluentd</code> 服务地址，实际环境中应该换成真实的地址。</p>
<p>具体使用 <code>fluentd</code> 的方法，请参考我写的一组 <code>fluentd</code> 日志收集的例子：<br><a href="https://coding.net/u/twang2218/p/docker-example/git/tree/master/fluentd" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-example/git/tree/master/fluentd</a></p>
<hr>
<h3 id="不同容器的日志汇聚到-fluentd-后如何区分？"><a href="#不同容器的日志汇聚到-fluentd-后如何区分？" class="headerlink" title="不同容器的日志汇聚到 fluentd 后如何区分？"></a>不同容器的日志汇聚到 fluentd 后如何区分？</h3><p>有两种概念的区分，一种是区分开<code>不同容器</code>的日志，另一种是区分开来<code>不同服务</code>的日志。</p>
<p>区分不同容器的日志是很直观的想法。运行了几个不同的容器，日志都送向日志收集，那么显然不希望 <code>nginx</code> 容器的日志和 <code>MySQL</code> 容器的日志混杂在一起看。</p>
<p>但是在 <code>Swarm</code> 集群环境中，区分容器就已经不再是合理的做法了。因为同一个服务可能有许多副本，而又有很多个服务，如果一个个的容器区分去分析，很难看到一个整体上某个服务的服务状态是什么样子的。而且，容器是短生存周期的，在维护期间容器生存死亡是很常见的事情。如果是像传统虚拟机那样子以容器为单元去分析日志，其结果很难具有价值。因此更多的时候是对某一个服务的日志整体分析，无需区别日志具体来自于哪个容器，不需要关心容器是什么时间产生以及是否消亡，只需要以服务为单元去区分日志即可。</p>
<p>这两类的区分日志的办法，<code>Docker</code> 都可以做到，这里我们以 <code>fluentd</code> 为例说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">        image: nginx:1.11-alpine</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;3000:80&quot;</span><br><span class="line">        labels:</span><br><span class="line">            section: frontend</span><br><span class="line">            group: alpha</span><br><span class="line">            service: web</span><br><span class="line">            image: nginx</span><br><span class="line">            base_os: alpine</span><br><span class="line">        logging:</span><br><span class="line">            driver: fluentd</span><br><span class="line">            options:</span><br><span class="line">                fluentd-address: &quot;localhost:24224&quot;</span><br><span class="line">                tag: &quot;frontend.web.nginx.&#123;&#123;.Name&#125;&#125;&quot;</span><br><span class="line">                labels: &quot;section,group,service,image,base_os&quot;</span><br></pre></td></tr></table></figure>
<p>这里我们运行了一个 <code>nginx:alpine</code> 的容器，服务名为 <code>web</code>。容器的日志使用 <code>fluentd</code> 进行收集，并且附上标签 <code>frontend.web.nginx.&lt;容器名&gt;</code>。除此以外，我们还定义了一组 <code>labels</code>，并且在 <code>logging</code> 的 <code>options</code> 中的 <code>labels</code> 中指明希望哪些标签随日志记录。这些信息中很多一部分都会出现在所收集的日志里。</p>
<p>让我们来看一下 <code>fluentd</code> 收到的信息什么样子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;frontend.web.nginx.service_web_1&quot;: &#123;</span><br><span class="line">    &quot;image&quot;: &quot;nginx&quot;,</span><br><span class="line">    &quot;base_os&quot;: &quot;alpine&quot;,</span><br><span class="line">    &quot;container_id&quot;: &quot;f7212f7108de033045ddc22858569d0ac50921b043b97a2c8bf83b1b1ee50e34&quot;,</span><br><span class="line">    &quot;section&quot;: &quot;frontend&quot;,</span><br><span class="line">    &quot;service&quot;: &quot;web&quot;,</span><br><span class="line">    &quot;log&quot;: &quot;172.20.0.1 - - [09/Dec/2016:15:02:45 +0000] \&quot;GET / HTTP/1.1\&quot; 200 612 \&quot;-\&quot; \&quot;curl/7.49.1\&quot; \&quot;-\&quot;&quot;,</span><br><span class="line">    &quot;group&quot;: &quot;alpha&quot;,</span><br><span class="line">    &quot;container_name&quot;: &quot;/service_web_1&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;stdout&quot;,</span><br><span class="line">    &quot;remote&quot;: &quot;172.20.0.1&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;-&quot;,</span><br><span class="line">    &quot;user&quot;: &quot;-&quot;,</span><br><span class="line">    &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;code&quot;: &quot;200&quot;,</span><br><span class="line">    &quot;size&quot;: &quot;612&quot;,</span><br><span class="line">    &quot;referer&quot;: &quot;-&quot;,</span><br><span class="line">    &quot;agent&quot;: &quot;curl/7.49.1&quot;,</span><br><span class="line">    &quot;forward&quot;: &quot;-&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果去除 <code>nginx</code> 正常的访问日志项目外，我们就可以更清晰的看到有哪些元数据信息可以利用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;frontend.web.nginx.service_web_1&quot;: &#123;</span><br><span class="line">    &quot;image&quot;: &quot;nginx&quot;,</span><br><span class="line">    &quot;base_os&quot;: &quot;alpine&quot;,</span><br><span class="line">    &quot;container_id&quot;: &quot;f7212f7108de033045ddc22858569d0ac50921b043b97a2c8bf83b1b1ee50e34&quot;,</span><br><span class="line">    &quot;section&quot;: &quot;frontend&quot;,</span><br><span class="line">    &quot;service&quot;: &quot;web&quot;,</span><br><span class="line">    &quot;group&quot;: &quot;alpha&quot;,</span><br><span class="line">    &quot;container_name&quot;: &quot;/service_web_1&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;stdout&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在 <code>logging</code> 下所有指定的 <code>labels</code> 都在。我们完全可以对每个服务设定不同的标签，通过标签来区分服务。比如这里，我们对 <code>web</code> 服务指定了 <code>service=web</code> 的标签，我们同样可以对数据库的服务设定标签为 <code>service=mysql</code>，这样在汇总后，只需要对 <code>service</code> 标签分组过滤即可，分离聚合不同服务的日志。</p>
<p>此外，我们可以设置不止一个标签，比如上面的例子，我们设置了多组不同颗粒度的标签，在后期分组的时候，可以很灵活的进行组合，以满足不同需求。</p>
<p>注意 <code>frontend.web.nginx.service_web_1</code> ，这是我们之前利用 <code>--log-opt tag=frontend.web.nginx.&lt;容器名&gt;</code> 进行设定的，其中 <code>&lt;容器名&gt;</code> 我们使用的是 <code>Go</code> 模板表达式， <code>\{\{.Name\}\}</code> （注意：前面这个<code>Name</code>需要舍去<code>\</code>转义符） 。<code>Go</code> 模板很强大，我们可以用它实现非常复杂的标签。在 <code>fluentd</code> 中，<code>&lt;match&gt;</code> 项可以根据标签来进行筛选。</p>
<p>这里可以唯一表示容器的，有容器 <code>ID container_id</code>，而容器名 <code>container_name</code> 也从某种程度上可以用来区分不同容器。因此进行容器区分日志的时候，可以使用这两项。还有一个 <code>source</code>，这表示了日志是从标准输出还是标准错误输出得到的，由此可以区分<code>正常日志</code>和<code>错误日志</code>。</p>
<p>现在我们可以知道，除了容器自身输出的信息外，<code>Docker</code> 还可以为每一个容器的日志添加很多元数据，以帮助后期的日志处理中应对不同需求的搜索和过滤。</p>
<p>在后期处理中，<code>fluentd</code> 中可以利用 <code>&lt;match&gt;</code> 或者 <code>&lt;filter&gt;</code> 插件根据 <code>tag</code> 或者其它元数据进行分别处理。而日志到了 <code>ElasticSearch</code> 这类系统后，则可以用更丰富的查询语言进行过滤、聚合。</p>
<hr>
<h2 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h2><h3 id="为什么容器一运行就退出啊？"><a href="#为什么容器一运行就退出啊？" class="headerlink" title="为什么容器一运行就退出啊？"></a>为什么容器一运行就退出啊？</h3><p>这是初学 <code>Docker</code> 常常碰到的问题，此时还以虚拟机来理解 <code>Docker</code>，认为启动 <code>Docker</code> 就是启动虚拟机，也没有搞明白<code>前台</code>和<code>后台</code>的区别。</p>
<p>首先，碰到这类问题<code>应该查日志</code>和<code>容器主进程退出码</code>。</p>
<p>检查容器日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器ID&gt;</span><br></pre></td></tr></table></figure>
<p>查看容器退出码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                           COMMAND             CREATED             STATUS                      PORTS                                                                  NAMES</span><br><span class="line">cc2aa3f4745f        ubuntu                          &quot;/bin/bash&quot;         23 hours ago        Exited (0) 22 hours ago                                                                            clever_lewin</span><br><span class="line">25510a2cb171        twang2218/gitlab-ce-zh:8.15.3   &quot;/assets/wrapper&quot;   2 days ago          Exited (127) 2 days ago                                                                            determined_mirzakhani</span><br></pre></td></tr></table></figure>
<p>在 <code>STATUS</code> 一栏中，可以看到退出码是多少。</p>
<ul>
<li>如果看到了 <code>Exited (127)</code> 那很可能是由于内存超标导致触发 <code>Out Of Memory</code> 然后被强制终止了。</li>
<li>如果看到了 <code>Exited (0)</code>，这说明容器主进程正常退出了。</li>
<li>如果是其他情况，应该检查容器日志。</li>
</ul>
<p>初学 Docker 的人常常会不理解既然正常怎么会退出的意思。不得不在强调一遍，Docker 不是虚拟机，<code>容器只是进程</code>。因此当执行 <code>docker run</code> 的时候，实际所做的只是启动一个进程，如果进程退出了，那么容器自然就终止了。</p>
<p>那么进程为什么会退出？</p>
<ul>
<li>如果是执行 <code>service nginx start</code> 这类启动后台服务程序的命令，那说明还是把 Docker 当做虚拟机了。Docker 启动的是进程，因此所谓的后台服务应该放到前台，比如应该 <code>nginx -g &#39;daemon off;&#39;</code> 这样直接前台启动应用才对。</li>
<li>如果发现 <code>COMMAND</code> 一栏是 <code>/bin/bash</code>，那还是说明把 Docker 当虚拟机了。<code>COMMAND</code> 应该是应用程序，而不交互式操作界面，容器不需要交互式操作界面。此外，如果使用 <code>/bin/bash</code> 希望起一个交互式的界面，那么也必须提供给其输入和终端，因此必须加 <code>-it</code> 选项，比如 <code>docker run -it ubuntu /bin/bash</code></li>
</ul>
<hr>
<h3 id="如何在-Docker-容器内使用-docker-命令-比如在-Jenkins-容器中-？"><a href="#如何在-Docker-容器内使用-docker-命令-比如在-Jenkins-容器中-？" class="headerlink" title="如何在 Docker 容器内使用 docker 命令(比如在 Jenkins 容器中)？"></a>如何在 Docker 容器内使用 docker 命令(比如在 Jenkins 容器中)？</h3><p>首先，不要在 Docker 容器中安装、运行 Docker 引擎，也就是所谓的 Docker In Docker (DIND)，参考文章：<br><a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" target="_blank" rel="noopener">https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/</a></p>
<p>为了让容器内可以构建镜像，应该使用 <code>Docker Remote API</code> 的<code>客户端</code>来直接调用宿主的 <code>Docker Engine</code>。可以是原生的 <code>Docker CLI</code> （<code>docker</code> 命令），也可以是<a href="https://docs.docker.com/engine/reference/api/remote_api_client_libraries/" target="_blank" rel="noopener">其它语言的库</a>。</p>
<h4 id="为-Jenkins-添加-Docker-命令行"><a href="#为-Jenkins-添加-Docker-命令行" class="headerlink" title="为 Jenkins 添加 Docker 命令行"></a>为 Jenkins 添加 Docker 命令行</h4><p>下面以定制 <code>jenkins</code> 镜像为例，使用 <code>Dockerfile</code> 添加 <code>docker</code> 命令行可执行文件，并调整权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM jenkins:alpine</span><br><span class="line"># 下载安装Docker CLI</span><br><span class="line">USER root</span><br><span class="line">RUN curl -O https://get.docker.com/builds/Linux/x86_64/docker-latest.tgz \</span><br><span class="line">    &amp;&amp; tar zxvf docker-latest.tgz \</span><br><span class="line">    &amp;&amp; cp docker/docker /usr/local/bin/ \</span><br><span class="line">    &amp;&amp; rm -rf docker docker-latest.tgz</span><br><span class="line"># 将 `jenkins` 用户的组 ID 改为宿主 `docker` 组的组ID，从而具有执行 `docker` 命令的权限。</span><br><span class="line">ARG DOCKER_GID=999</span><br><span class="line">USER jenkins:$&#123;DOCKER_GID&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子里，我们下载了静态编译的 <code>docker</code> 可执行文件，并提取命令行安装到系统目录下。然后调整了 <code>jenkins</code> 用户的组 ID，调整为宿主 <code>docker</code> 组ID，从而使其具有执行 <code>docker</code> 命令的权限。</p>
<p>组 ID 使用了 <code>DOCKER_GID</code> 参数来定义，以方便进一步定制。<code>构建时</code>可以通过 <code>--build-arg</code> 来改变 <code>DOCKER_GID</code> 的默认值，<code>运行时</code>也可以通过 <code>--user jenkins:1234</code> 来改变运行用户的身份。</p>
<blockquote>
<p>这里的基础镜像使用的是 <code>jenkins:alpine</code>，换为非 <code>alpine</code> 的镜像 <code>jenkins:latest</code> 也是一样的。</p>
</blockquote>
<p>用下面的命令来构建镜像（假设镜像名为 <code>jenkins-docker</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t jenkins-docker .</span><br></pre></td></tr></table></figure>
<p>如果需要构建时调整 <code>docker</code> 组 <code>ID</code>，可以使用 <code>--build-arg</code> 来覆盖参数默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t jenkins-docker --build-arg DOCKER_GID=1234 .</span><br></pre></td></tr></table></figure>
<p>在启动容器的时候，将宿主的 <code>/var/run/docker.sock</code> 文件挂载到容器内的同样位置，从而让容器内可以通过 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">unix socket</a> 调用宿主的 <code>Docker</code> 引擎。</p>
<p>比如，可以用下面的命令启动 <code>jenkins</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name jenkins \</span><br><span class="line">    -d \</span><br><span class="line">    -p 8080:8080 \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    jenkins-docker</span><br></pre></td></tr></table></figure>
<p>在 <code>jenkins</code> 容器中，就已经可以执行 <code>docker</code> 命令了，可以通过 <code>docker exec</code> 来验证这个结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it jenkins sh</span><br><span class="line">/ $ id</span><br><span class="line">uid=1000(jenkins) gid=999(ping) groups=999(ping)</span><br><span class="line">/ $ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      1.12.3</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.3</span><br><span class="line"> Git commit:   6b644ec</span><br><span class="line"> Built:        Wed Oct 26 23:26:11 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line">Server:</span><br><span class="line"> Version:      1.13.0-rc2</span><br><span class="line"> API version:  1.25</span><br><span class="line"> Go version:   go1.7.3</span><br><span class="line"> Git commit:   1f9b3ef</span><br><span class="line"> Built:        Wed Nov 23 06:32:39 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line">/ $</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Docker-容器如何随系统一同启动？"><a href="#Docker-容器如何随系统一同启动？" class="headerlink" title="Docker 容器如何随系统一同启动？"></a>Docker 容器如何随系统一同启动？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--restart=always</span><br></pre></td></tr></table></figure>
<p>参考官网文档：<a href="https://docs.docker.com/engine/reference/commandline/run/#restart-policies-restart" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/#restart-policies-restart</a></p>
<hr>
<h3 id="docker-stats-显示的只有容器ID，怎么才能显示容器名字？"><a href="#docker-stats-显示的只有容器ID，怎么才能显示容器名字？" class="headerlink" title="docker stats 显示的只有容器ID，怎么才能显示容器名字？"></a>docker stats 显示的只有容器ID，怎么才能显示容器名字？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps --format=&apos;&#123;&#123;.Names&#125;&#125;&apos;)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="我用的是阿里云-Ubuntu-14-04-主机，内核还是3-13，怎么办？"><a href="#我用的是阿里云-Ubuntu-14-04-主机，内核还是3-13，怎么办？" class="headerlink" title="我用的是阿里云 Ubuntu 14.04 主机，内核还是3.13，怎么办？"></a>我用的是阿里云 Ubuntu 14.04 主机，内核还是3.13，怎么办？</h3><p>其实 <code>Ubuntu 14.04</code> 官方维护的内核已经到 <code>4.4</code> 了，可以通过下面的命令<code>升级内核</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y --install-recommends linux-generic-lts-xenial</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="如何动态修改内存限制？"><a href="#如何动态修改内存限制？" class="headerlink" title="如何动态修改内存限制？"></a>如何动态修改内存限制？</h3><p><code>Docker 1.10</code> 之后支持<code>动态修改</code>，使用 <code>docker update</code> 命令，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update -m 300m</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="经常在各种-Docker-命令里看到-–label，label-是什么？干什么用的？"><a href="#经常在各种-Docker-命令里看到-–label，label-是什么？干什么用的？" class="headerlink" title="经常在各种 Docker 命令里看到 –label，label 是什么？干什么用的？"></a>经常在各种 Docker 命令里看到 –label，label 是什么？干什么用的？</h3><p><code>Label</code> 是<code>键值对</code>，是 <code>metadata</code>（<code>元数据</code>）是贯穿于 <code>Docker</code> 各个资源的，包括<code>引擎</code>、<code>镜像</code>、<code>容器</code>、<code>卷</code>、<code>网络</code>、<code>Swarm 节点</code>、<code>服务</code>等。</p>
<ul>
<li>键 <code>key</code>：格式要求只可以包含<code>字母</code>和<code>数字</code>，以及<code>.</code>，<code>-</code>。推荐使用类似于 <code>Java</code> 那种<code>反向域名格式</code>，如 <code>com.example.mytag</code>。</li>
<li>值 <code>value</code>：格式必须是<code>字符串</code>，除了普通字符串外，还可以是 <code>JSON</code>, <code>XML</code>, <code>CSV</code> 或者 <code>YAML</code>，当然，需要先进行<code>序列化</code>。</li>
</ul>
<p>当资源很少的时候，我们可以直接对一个个资源进行操作，但是，在管理很多资源的时候，这么做就变得不大现实。经常的需求是针对某一类的资源进行操作，而不是一个个的操作。这种情况，经常会使用 <code>label</code> 来帮助实现。</p>
<p>当创建一个资源的时候，可以指定这个资源的 <code>label</code>（<code>一个资源可以有很多个 label</code>），而当创建了很多个资源的时候，就可以通过过滤 <code>label</code> 的键、值来得到所需的资源列表。</p>
<p>比如，我们可以使用 <code>docker run</code> 运行一堆容器，在运行时，通过 <code>label</code> 指定容器是架构中的哪一部分。</p>
<ul>
<li>前端：–label type=frontend</li>
<li>中间件：–label type=middleware</li>
<li>存储：–label type=storage</li>
</ul>
<p>在后期维护时，可以直接过滤显示想要的容器，比如我们只想看前端容器运行情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps --filter label=type=frontend</span><br></pre></td></tr></table></figure>
<p>而且，还可以进一步的和其它命令配合操作这组容器，比如我们需要停止所有前端容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -f label=type=frontend)</span><br></pre></td></tr></table></figure>
<p>使用 <code>label</code> 在集群调度中也非常有用。</p>
<p>比如，我们可以在不同的 <code>Docker</code> 主机的引擎 <code>dockerd</code> 参数中，通过 <code>label</code> 来加入存储类型的信息，如：</p>
<ul>
<li>存储类型为 <code>SSD</code>：<code>--label storage=ssd</code></li>
<li>存储类型为 <code>HDD</code>：<code>--label storage=hdd</code></li>
</ul>
<p>对于<code>数据库的服务，我们自然希望跑在 SSD 上以获得更大的性能</code>，而<code>日志、备份服务则希望跑在 HDD 上获得更高的容量</code>。那么可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">    --name mysql \</span><br><span class="line">    --constraint &apos;engine.labels.storage == ssd&apos; \</span><br><span class="line">    mysql</span><br></pre></td></tr></table></figure>
<h4 id="添加label以及过滤"><a href="#添加label以及过滤" class="headerlink" title="添加label以及过滤"></a>添加label以及过滤</h4><p>添加 <code>label</code> 大多格式都是在创建、修改资源时，使用 <code>--label &lt;key&gt;=&lt;value&gt;</code> 参数（部分命令提供了 <code>-l</code> 缩写形式）。<code>value</code> 可以省略，格式为 <code>--label &lt;key&gt;</code>。如果需要定义多组 <code>label</code>，只需多组 <code>--label</code> 即可。</p>
<p>过滤 <code>label</code> 则大多发生在列表命令中，使用 <code>--filter label=&lt;key&gt;=&lt;value&gt;</code>，或者对于不关心 <code>value</code> 的情况，<code>--filter label=&lt;key&gt;</code>（部分命令提供了 <code>-f</code> 的缩写形式）。</p>
<p>下面的列表，列出了支持 <code>label</code> 的命令（除非特殊声明，”添加”命令使用 <code>--label</code> 选项添加 <code>label</code>；”过滤”命令使用 <code>--filter</code> 过滤<code>label</code>）：</p>
<ul>
<li>Docker 引擎<ul>
<li>添加：<code>dockerd</code>： <a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/</a></li>
</ul>
</li>
<li><p>镜像</p>
<ul>
<li>添加：<ul>
<li><code>docker build</code>：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/build/</a></li>
<li><code>Dockerfile</code> 中的 <code>LABEL</code>（会继承<code>FROM</code>镜像的<code>LABEL</code>）：<a href="https://docs.docker.com/engine/reference/builder/#/label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/#/label</a></li>
</ul>
</li>
<li>过滤：<code>docker images</code>：<a href="https://docs.docker.com/engine/reference/commandline/images/#/filtering" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/images/#/filtering</a></li>
</ul>
</li>
<li><p>容器</p>
<ul>
<li>添加：<code>docker create</code>：<a href="https://docs.docker.com/engine/reference/commandline/create/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/create/</a><ul>
<li>除了 <code>--label</code> 外，<code>docker create</code> 还支持使用选项 <code>--label-file</code> 从文件中加载 <code>label</code></li>
</ul>
</li>
<li>添加：<code>docker run</code>：<a href="https://docs.docker.com/engine/reference/commandline/run/#/set-metadata-on-container--l---label---label-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/#/set-metadata-on-container--l---label---label-file</a><ul>
<li>除了 <code>--label</code> 外，<code>docker run</code> 还支持使用选项 <code>--label-file</code> 从文件中加载 <code>label</code></li>
</ul>
</li>
<li>过滤：<code>docker ps</code>：<a href="https://docs.docker.com/engine/reference/commandline/ps/#/label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/ps/#/label</a></li>
</ul>
</li>
<li><p>卷</p>
<ul>
<li>添加：<code>docker volume create</code>：<a href="https://docs.docker.com/engine/reference/commandline/volume_create/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/volume_create/</a></li>
<li>过滤：<code>docker volume ls</code>：<a href="https://docs.docker.com/engine/reference/commandline/volume_ls/#/filtering" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/volume_ls/#/filtering</a></li>
</ul>
</li>
<li><p>网络</p>
<ul>
<li>添加：<code>docker network create</code>：<a href="https://docs.docker.com/engine/reference/commandline/network_create/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/network_create/</a></li>
<li>过滤：<code>docker network ls</code>：<a href="https://docs.docker.com/engine/reference/commandline/network_ls/#/filtering" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/network_ls/#/filtering</a></li>
</ul>
</li>
<li><p>Swarm 节点</p>
<ul>
<li><code>docker node update</code>：<a href="https://docs.docker.com/engine/reference/commandline/node_update/#/add-label-metadata-to-a-node" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/node_update/#/add-label-metadata-to-a-node</a><ul>
<li>添加：<code>--label-add</code></li>
<li>删除：<code>--label-rm</code></li>
</ul>
</li>
<li>过滤：<code>docker node ls</code>：<a href="https://docs.docker.com/engine/reference/commandline/node_ls/#/filtering" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/node_ls/#/filtering</a></li>
<li>过滤：<code>docker node ps</code>：<a href="https://docs.docker.com/engine/reference/commandline/node_ps/#/label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/node_ps/#/label</a></li>
</ul>
</li>
<li><p>服务</p>
<ul>
<li>添加：<code>docker service create</code>：<a href="https://docs.docker.com/engine/reference/commandline/service_create/#/set-metadata-on-a-service--l---label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_create/#/set-metadata-on-a-service--l---label</a><ul>
<li>除了 <code>--label</code> 外，还可以通过 <code>--container-label</code> 来添加容器 <code>label</code></li>
</ul>
</li>
<li><code>docker service update</code>：<a href="https://docs.docker.com/engine/reference/commandline/service_update/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_update/</a><ul>
<li>添加容器 <code>label</code>：<code>--container-label-add</code></li>
<li>删除容器 <code>label</code>：<code>--container-label-rm</code></li>
<li>添加服务 <code>label</code>：<code>--label-add</code></li>
<li>删除服务 <code>label</code>：<code>--label-rm</code></li>
</ul>
</li>
<li>过滤：<code>docker service ls</code>：<a href="https://docs.docker.com/engine/reference/commandline/service_ls/#/label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_ls/#/label</a></li>
</ul>
</li>
</ul>
<p>除了上述资源外，<code>docker events</code> 也可以使用 <code>label</code> 过滤结果：<a href="https://docs.docker.com/engine/reference/commandline/events/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/events/</a></p>
<h4 id="集群调度约束"><a href="#集群调度约束" class="headerlink" title="集群调度约束"></a>集群调度约束</h4><ul>
<li>一代 Swarm：使用环境变量添加约束<ul>
<li><code>docker run</code>：<code>-e constraint:storage==sdd</code>：<a href="https://docs.docker.com/swarm/scheduler/filter/#/how-to-write-filter-expressions" target="_blank" rel="noopener">https://docs.docker.com/swarm/scheduler/filter/#/how-to-write-filter-expressions</a></li>
<li><code>docker-compose.yml</code>：使用 <code>environment</code> 来进行约束：<a href="https://docs.docker.com/compose/swarm/#/manual-scheduling" target="_blank" rel="noopener">https://docs.docker.com/compose/swarm/#/manual-scheduling</a></li>
</ul>
</li>
</ul>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;2&quot;</span><br><span class="line">services:</span><br><span class="line">    redis:</span><br><span class="line">        image: redis</span><br><span class="line">        environment:</span><br><span class="line">            - &quot;constraint:storage==ssd&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>二代 Swarm<ul>
<li><code>docker service create</code>：<code>--constraint value</code>：<a href="https://docs.docker.com/engine/reference/commandline/service_create/#/specify-service-constraints---constraint" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_create/#/specify-service-constraints---constraint</a></li>
</ul>
</li>
</ul>
<p>如下面的例子中，使用 <code>Swarm 节点</code> 的 <code>label</code> 进行约束（注意，这次用的不是<code>引擎</code>的<code>label</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">    --name web \</span><br><span class="line">    --constraint &apos;node.labels.type == frontend&apos; \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="都说不要用-root-去运行服务，但我看到的-Dockerfile-都是用-root-去运行，这不安全吧？"><a href="#都说不要用-root-去运行服务，但我看到的-Dockerfile-都是用-root-去运行，这不安全吧？" class="headerlink" title="都说不要用 root 去运行服务，但我看到的 Dockerfile 都是用 root 去运行，这不安全吧？"></a>都说不要用 root 去运行服务，但我看到的 Dockerfile 都是用 root 去运行，这不安全吧？</h3><p>并非所有官方镜像的 <code>Dockerfile</code> 都是用 <code>root</code> 用户去执行的。比如 <code>mysql</code> 镜像的执行身份就是 <code>mysql</code> 用户；<code>redis</code> 镜像的服务运行用户就是 <code>redis</code>；<code>mongo</code> 镜像内的服务执行身份是 <code>mongo</code> 用户；<code>jenkins</code> 镜像内是 <code>jenkins</code> 用户启动服务等等。所以说 “都是用 <code>root</code> 去运行” 是不客观的。</p>
<p>当然，这并不是说在<code>容器内</code>使用 <code>root</code> 就非常危险。<code>容器内的 root 和宿主上的 root 不同</code>，容器内的 <code>root</code> 虽然 <code>uid</code> 也默认为 <code>0</code>，但是却处于一个隔离的命名空间，而且被去掉了大量的特权。<code>容器内的 root 是一个没有什么特权的用户，危险的操作基本都无法执行。</code></p>
<p>不过，如果用户可以打破这个安全保护，那就是另外一回事了。比如，<code>如果用户挂载了宿主目录给容器，这就是打通了一个容器内的 root 操控宿主的一个通道，使得容器内的 root 可以修改所挂载的目录下的任何文件。</code></p>
<p>因为当前版本的 <code>Docker</code> 中，<code>默认情况下</code>容器的 <code>user namespace</code> 并未开启，所以<code>容器内的用户和宿主用户共享 uid 空间。</code>容器内的 <code>uid</code> 为 <code>0</code> 的 <code>root</code>，就被系统视为 <code>uid=0</code> 的宿主 <code>root</code>，因此磁盘读写时，具有宿主 <code>root</code> 同等读写权限。<code>这也是为什么一般不推荐挂载宿主目录、特别是挂载宿主系统目录的原因之一</code>。这一切<code>只要定制镜像的时候，容器内不使用 root 启动服务就没这个问题了</code>。</p>
<p>当然，上面说的问题只是默认情况下 <code>user namespace</code> 不会启用的问题。<code>dockerd</code> 有一个 <code>--userns-remap</code> 参数，只要配置了这个参数，就可以确保容器内的 <code>uid</code> 是独立命名空间，容器内的 <code>uid</code> 变到宿主的时候，会被 <code>remap</code> 到另一个范围。因此，容器内的 <code>uid=0</code> 的 <code>root</code> 将完全跟 <code>root</code> 没有任何关系，仅仅是个普通用户而已。</p>
<p>相关信息请参考官方文档：</p>
<ul>
<li><code>--userns-remap</code> 的介绍：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/daemon-user-namespace-options" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/daemon-user-namespace-options</a></li>
<li>Docker 安全：<a href="https://docs.docker.com/engine/security/security/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/security/</a></li>
</ul>
<hr>
<h3 id="我在容器里运行-systemctl-start-xxx-怎么报错啊？"><a href="#我在容器里运行-systemctl-start-xxx-怎么报错啊？" class="headerlink" title="我在容器里运行 systemctl start xxx 怎么报错啊？"></a>我在容器里运行 systemctl start xxx 怎么报错啊？</h3><p>如果在容器内使用 <code>systemctl</code> 命令，经常会发现碰到这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br></pre></td></tr></table></figure>
<p>这很正常，因为 <code>systemd</code> 是<code>完整系统</code>的服务启动、维护的系统服务程序，而且<code>需要特权</code>去执行。但是容器不是完整系统，既没有配合的服务，也没有特权，所以自然用不了。</p>
<p>如果你碰到这样的问题，只能再次提醒你，<code>Docker 不是虚拟机</code>。试图在容器里执行 <code>systemctl</code> 命令的，大多都是还没有搞明白容器和虚拟机的区别，因为看到了可以有 Shell，就以为这是个虚拟机，试图重复自己在完整系统上的体验。这是用法错误，<code>不要把 Docker 当做虚拟机去用，容器有自己的用法</code>。</p>
<blockquote>
<p>Docker 不是虚拟机，容器只是受限进程。</p>
</blockquote>
<p>容器内根本不需要后台服务，也不需要服务调度和维护，自然也不需要 <code>systemd</code>。容器只有一个主进程，也就是应用进程。容器的生存周期就是围绕着这个主进程而存在的，所以所试图启动的后台服务，应该改为直接在前台运行，根本不需要也不应该使用 <code>systemctl</code> 命令去在后台加载。日志之类的也是直接从 <code>stdout/stderr</code> 输出，而不是走 <code>journald</code>。</p>
<hr>
<h3 id="容器内的时间和宿主不一致，怎么同步啊？"><a href="#容器内的时间和宿主不一致，怎么同步啊？" class="headerlink" title="容器内的时间和宿主不一致，怎么同步啊？"></a>容器内的时间和宿主不一致，怎么同步啊？</h3><p>问这个问题的人往往混淆了<code>时间</code>和<code>时区</code>的概念。  </p>
<p><code>时间</code>是从 <code>epoch</code> 到当前的<code>秒数</code>或者<code>毫秒数</code>，<code>全球都一样</code>，这是<code>绝对值</code>；而<code>时区</code>则是由于<code>地理位置差异</code>、行政区划导致各地显示时间的差异。</p>
<p>对于 <code>Docker</code> 容器而言，根本不存在宿主和容器的时间差异问题，因为他们使用的是<code>同一个内核</code>、同一个时钟，二者完全一样，所以<code>根本不存在同步</code>问题。还是那句话 <code>Docker 不是虚拟机</code>。</p>
<p>所看到的差异，如果细心一点，很可能会发现其实根本不是<code>时间</code>同步问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu bash</span><br><span class="line">root@08c6ad41f343:/# date</span><br><span class="line">Tue Dec 13 01:36:37 UTC 2016</span><br></pre></td></tr></table></figure>
<p>注意到 <code>UTC</code> 了么，这是说使用的是国际标准 <code>0</code> 时区 的时间显示，因此这只是显示所用的时区设置差异问题。而且之前如果稍微注意一下，就会发现所谓时间不一致，实际上是整整差了 <code>8</code> 个小时，还记得中学地理课上讲的中国时区是多少么？是 <code>+8</code> 时区，所以自然和 <code>0</code> 时区 差了 <code>8</code> 个小时。应该很快就意识到是自己的时区设错了（或者偷懒没设）导致。</p>
<p>解决办法很简单，<code>设置时区即可</code>。一般情况直接<code>设置环境变量 TZ</code> 就够了，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -e TZ=Asia/Shanghai debian bash</span><br><span class="line">root@8e6d6c588328:/# date</span><br><span class="line">Tue Dec 13 09:41:21 CST 2016</span><br></pre></td></tr></table></figure>
<p>看到了么？时区调整到了 <code>CST</code>，也就是<code>China Standard Time - 中国标准时间</code>，因此显示就正常了。</p>
<p>不过并非所有系统都可以如此方便的设置时区。可以直接使用 <code>TZ=Asia/Shanghai</code> 环境变量修改时区的系统有：</p>
<ul>
<li><code>centos</code> (<code>5</code>, <code>6</code>, <code>7</code>)</li>
<li><code>debian</code> (<code>7</code>, <code>8</code>, <code>9</code>)</li>
<li><code>fedora</code> (<code>24</code>, <code>25</code>, <code>26</code>)</li>
<li><code>ubuntu</code> (<code>14.04</code>)</li>
</ul>
<p>而下面的这些系统可能出于镜像体积的考虑，去掉了时区的软件包 <code>tzdata</code>，因此需要在 <code>Dockerfile</code> 中<code>先行安装时区包</code>。</p>
<ul>
<li><code>ubuntu</code>: (<code>16.04</code>, <code>17.04</code>, <code>17.10</code>) (~15MB)<br>Dockerfile:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN set -xe \</span><br><span class="line">  &amp;&amp; apt-get update \</span><br><span class="line">  &amp;&amp; apt-get install tzdata locales \</span><br><span class="line">  &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>alpine</code> (~1.3MB)<br>Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apk --no-cache add tzdata</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>opensuse</code> (~12MB)<br>Dockerfile:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN set -xe \</span><br><span class="line">    &amp;&amp; zypper --non-interactive refresh \</span><br><span class="line">    &amp;&amp; zypper --non-interactive -qn install --no-recommends timezone \</span><br><span class="line">    &amp;&amp; zypper --non-interactive clean -a</span><br></pre></td></tr></table></figure>
<ul>
<li><code>clearlinux</code> (~280MB)<br>Dockerfile:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN set -xe \</span><br><span class="line">    &amp;&amp; swupd bundle-add sysadmin-basic \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/swupd/*</span><br></pre></td></tr></table></figure>
<p>上面列表除了列出系统外，还给出了每个系统需要添加到 <code>Dockerfile</code> 的安装包的命令，以及<code>安装后镜像体积增加的大小</code>。其中 <code>clearlinux</code> <code>不能单个安装软件包</code>，所以体积增加的有些夸张，因此更好地办法是直接 <code>COPY</code> 时区信息进镜像。</p>
<blockquote>
<p>注意：<code>ubuntu:16.04</code> 以后的版本，在 2017年4月10 日以后，已经去除 <code>tzdata</code>，因此要改变其时区需要进行时区安装操作，而<code>不是</code>像以前那样只需配置 <code>TZ</code> 环境变量即可。不过大部分<code>官方镜像</code>是基于 <code>debian</code> 的，因此它们<code>不受影响</code>。<br>参考 issue:</p>
<ul>
<li><a href="https://bugs.launchpad.net/cloud-images/+bug/1682622" target="_blank" rel="noopener">https://bugs.launchpad.net/cloud-images/+bug/1682622</a></li>
<li><a href="https://bugs.launchpad.net/cloud-images/+bug/1682305" target="_blank" rel="noopener">https://bugs.launchpad.net/cloud-images/+bug/1682305</a></li>
<li><a href="https://github.com/docker-library/official-images/issues/2863" target="_blank" rel="noopener">https://github.com/docker-library/official-images/issues/2863</a></li>
<li><a href="https://github.com/docker-library/official-images/issues/2856" target="_blank" rel="noopener">https://github.com/docker-library/official-images/issues/2856</a></li>
</ul>
</blockquote>
<p>这仅仅是<code>调整容器内系统环境的时区</code>，大部分程序都会遵循这个标准。但是有些应用并不遵守这类约定，会使用<code>自己的时区设置</code>。</p>
<p>一般应用、服务的配置文件里一般都有时区选项，应该根据自己需求把中国时区配上。</p>
<p>比如，PHP 配置文件中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Date]</span><br><span class="line">date.timezone = Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>再比如 <code>mysqld</code> 中的参数 <code>--timezone=Asia/Shanghai</code>；<code>Java</code> 的 <code>-Duser.timezone=Asia/Shanghai</code> <code>JVM</code> 参数，都可以指定上层应用时区，而不依赖于系统默认时区，这也是推荐的做法。避免系统部署时受系统时区影响，这在全球云服务器环境中其实很常见，因此尽量在应用层设置好。很多应用都有自己的时区设置，应该去了解一下并且进行设置，不要总用默认值。</p>
<p>一些人在配置服务的时候很懒惰，只要默认能用即可，而不会一一检查每一个配置的默认值是否和自己期望一致，这是很不专业的做法，正是这种不专业才导致了出现了这种问题。所以做事情，一定要让自己以专业的视角和态度看问题。</p>
<hr>
<h3 id="我想让我的程序平滑退出，为什么截获-SIGTERM-信号不管用啊？"><a href="#我想让我的程序平滑退出，为什么截获-SIGTERM-信号不管用啊？" class="headerlink" title="我想让我的程序平滑退出，为什么截获 SIGTERM 信号不管用啊？"></a>我想让我的程序平滑退出，为什么截获 SIGTERM 信号不管用啊？</h3><p><code>docker stop</code>, <code>docker service rm</code> 在停止容器时，都会先发 <code>SIGTERM</code> 信号，等待一段时间（默认为 <code>10</code> 秒）后，如果程序没响应，则强行 <code>SIGKILL</code> 杀掉进程。</p>
<p>这样应用进程就有机会平滑退出，在接收到 <code>SIGTERM</code> 后，可以去 <code>Flush 缓存</code>、<code>完成文件读写</code>、<code>关闭数据库连接</code>、<code>释放文件资源</code>、<code>释放锁</code>等等，然后再退出。所以试图截获 <code>SIGTERM</code> 信号的做法是对的。</p>
<p>但是，可能在截获 <code>SIGTERM</code> 时却发现应用并没有收到 <code>SIGTERM</code>，于是盲目的认为 <code>Docker</code> 不支持平滑退出，其实并非如此。</p>
<p>还记得我们提到过，<code>Docker 不是虚拟机，容器只是受限进程，而一个容器只应该跑一个主进程的说法么</code>？如果你发现你的程序没有截获到 <code>SIGTERM</code>，那就很可能你没有遵循这个最佳实践的做法。因为 <code>SIGTERM</code> 只会发给<code>主进程</code>，也就是容器内 <code>PID</code> 为 <code>1</code> 的进程。</p>
<p>原因包括：</p>
<ul>
<li><p>至于说主进程启动的那些子进程，完全看主进程是否愿意转发 <code>SIGTERM</code> 给子进程了。所以那些把 <code>Docker</code> 当做虚拟机用的，<code>主进程跑了个 bash，然后 exec 进去启动程序的，或者来个 &amp; 让程序跑后台的情况，应用进程必然无法收到 SIGTERM</code>。</p>
</li>
<li><p>还有一种可能是在 <code>Dockerfile</code> 中的 <code>CMD</code> 那行用的是 <code>shell</code> 格式写的命令，而不是 <code>exec</code> 格式。还记得前面提到过的 <code>shell</code> 格式的命令，会加一个 <code>sh -c</code> 来去执行么？因此使用 <code>shell</code> 格式写 <code>CMD</code> 的时候，<code>PID</code> 为 <code>1</code> 的进程是 <code>sh</code>，而<code>它不转发信号，所以主程序收不到</code>。</p>
</li>
</ul>
<p>明白了道理，解决方法就很简单，换成 <code>exec</code> 格式，并且<code>将主进程执行文件放在第一位即可</code>。这也是为什么之前推荐 <code>exec</code> 格式的原因之一。</p>
<hr>
<h2 id="Docker-Compose-相关问题"><a href="#Docker-Compose-相关问题" class="headerlink" title="Docker Compose 相关问题"></a>Docker Compose 相关问题</h2><h3 id="你那个-LNMP-例子中的-docker-compose-yml-中有好多-networks，都是什么意思啊？"><a href="#你那个-LNMP-例子中的-docker-compose-yml-中有好多-networks，都是什么意思啊？" class="headerlink" title="你那个 LNMP 例子中的 docker-compose.yml 中有好多 networks，都是什么意思啊？"></a>你那个 LNMP 例子中的 docker-compose.yml 中有好多 networks，都是什么意思啊？</h3><p>我写的 <code>LNMP</code> 多容器互通的例子：<a href="https://coding.net/u/twang2218/p/docker-lnmp/git" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git</a></p>
<p>前面 <code>services</code> 下的每个服务下面的 <code>networks</code>，是说这个服务要接到哪个网络上。<br>而最后的那个总的<code>networks</code>下面的，是这几个网络的定义。</p>
<p>也就是说，<code>nginx</code> 接到了名为 <code>frontend</code> 的前端网络；<code>mysql</code> 接到了名为 <code>backend</code> 的后端网络；而作为中间的 <code>php</code> 既需要和 <code>nginx</code> 通讯，又需要和 <code>mysql</code> 通讯，所以同时连接了 <code>frontend</code> 和 <code>backend</code> 网络。由于 <code>nginx</code> 和 <code>mysql</code> 不处于同一网络，所以二者无法通讯，起到了隔离的作用。（另外需要注意的是，每个服务都要指定network，如果没有指定想要连接的网络，则会使用默认网络，这样就无法与你自定义的网络通信了）</p>
<p>关于 Docker 自定义网络，你可以看一下官方文档的介绍：<br><a href="https://docs.docker.com/engine/userguide/networking/dockernetworks/#/user-defined-networks" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/dockernetworks/#/user-defined-networks</a></p>
<p>关于在 Docker Compose 中使用自定义网络的部分，可以看官方这部分文档：<br><a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">https://docs.docker.com/compose/networking/</a></p>
<hr>
<h3 id="使用-Compose-的时候碰到-“An-HTTP-request-took-too-long-to-complete…-”-错误，怎么办？"><a href="#使用-Compose-的时候碰到-“An-HTTP-request-took-too-long-to-complete…-”-错误，怎么办？" class="headerlink" title="使用 Compose 的时候碰到 “An HTTP request took too long to complete….” 错误，怎么办？"></a>使用 Compose 的时候碰到 “An HTTP request took too long to complete….” 错误，怎么办？</h3><p>Compose 的请求超时时限是可以配置的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export COMPOSE_HTTP_TIMEOUT=120</span><br></pre></td></tr></table></figure>
<p>不过，这不是问题的解决办法，因为一般情况下不应该超时，超时的原因是因为所访问的 <code>Docker Engine 过于繁忙</code>，而无法响应 <code>Compose</code> 的请求。应该检查具体 <code>Docker Engine</code> 出了什么问题，是不是还在用着 <code>CentOS</code> 默认的 <code>device mapper</code> 的 <code>loop</code> 设备，等等。</p>
<hr>
<h2 id="Docker-Swarm-相关问题"><a href="#Docker-Swarm-相关问题" class="headerlink" title="Docker Swarm 相关问题"></a>Docker Swarm 相关问题</h2><h3 id="我的-Docker-版本是-1-12，请问我跑的是一代-Swarm-还是二代-Swarm-啊？"><a href="#我的-Docker-版本是-1-12，请问我跑的是一代-Swarm-还是二代-Swarm-啊？" class="headerlink" title="我的 Docker 版本是 1.12，请问我跑的是一代 Swarm 还是二代 Swarm 啊？"></a>我的 Docker 版本是 1.12，请问我跑的是一代 Swarm 还是二代 Swarm 啊？</h3><p>自己运行的 Swarm 怎么会连自己都不知道跑的是啥？</p>
<p>首先，至于是运行的一代 Swarm 还是二代 Swarm，单看版本是没意义的。<code>Docker 1.12+ 的版本同时支持一代 Swarm 和二代 Swarm</code>。</p>
<p>如果是使用<code>容器形式</code>运行的 <code>Swarm</code>，也就是 <code>docker run swarm</code> 形式构建的 <code>Swarm</code>，这是<code>一代 Swarm</code>，也被称为 <code>Docker Swarm</code>。</p>
<p>如果是使用<code>内置命令</code>形式构建的 <code>Swarm</code>，也就是使用命令 <code>docker swarm init</code> 形式构建的 <code>Swarm</code>，这是内置的 Swarm，是<code>二代 Swarm</code>，也被称为 <code>Docker Swarm Mode</code>。</p>
<hr>
<h3 id="Swarm环境中怎么指定某个容器在指定的宿主上运行呢？"><a href="#Swarm环境中怎么指定某个容器在指定的宿主上运行呢？" class="headerlink" title="Swarm环境中怎么指定某个容器在指定的宿主上运行呢？"></a>Swarm环境中怎么指定某个容器在指定的宿主上运行呢？</h3><p>每个 <code>Docker Host</code> 建立时都可以通过 <code>--label</code> 指定其 <code>Docker 引擎的标签</code>，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dockerd \</span><br><span class="line">    --label com.example.environment=&quot;production&quot; \</span><br><span class="line">    --label com.example.storage=&quot;ssd&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，上面的配置参数应该配置在 <code>Docker</code> 引擎的<code>配置文件</code>里修改，如 <code>docker.service</code>，而不是简单的命令行执行</p>
</blockquote>
<p>然后运行容器时，使用<code>环境变量约束调度即可</code>。可以使用 <code>Compose</code> 文件的 <code>environment</code> 配置，也可以使用 <code>docker run</code> 的 <code>-e</code> 环境变量参数。下面以 <code>Compose</code> 配置文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;2&quot;</span><br><span class="line">services:</span><br><span class="line">  mongodb:</span><br><span class="line">    image: mongo:latest</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;constraint:com.example.storage==ssd&quot;</span><br></pre></td></tr></table></figure>
<p>这样这个 <code>mongodb</code> 的服务就会运行在标记为 <code>com.example.storage=&quot;ssd&quot;</code> 的宿主上运行。</p>
<hr>
<h3 id="为什么-Swarm-集群的-overlay-network-跨宿主无法互访？"><a href="#为什么-Swarm-集群的-overlay-network-跨宿主无法互访？" class="headerlink" title="为什么 Swarm 集群的 overlay network 跨宿主无法互访？"></a>为什么 Swarm 集群的 overlay network 跨宿主无法互访？</h3><p>首先，检查建立 Swarm 的时候，对其它节点所宣告的本节点的地址是否正确。</p>
<p>对于单网卡、单IP的宿主，Swarm 会自动选择网卡地址，但是多网卡、多IP的宿主，就必须手动宣告地址。</p>
<p>对于一代 Swarm 而言，检查一下 <code>dockerd</code> 的配置中，<code>--cluster-advertise</code> 地址是否配置正确。<br>对于二代 Swarm，则检查一下创建、加入 Swarm 的时候，<code>--advertise-addr</code> 是否填写正确。<br>宣告地址必须是全集群可以互访的，由于该地址端口是 <code>Docker Remote API</code> 端口，所以可以用 <code>curl</code> 来连接其它节点，以判断互通性。</p>
<p>然后，检查宿主间的网络互通问题，特别是宿主的防火墙开启的情况下，检查下列服务端口有没有放开：</p>
<ul>
<li><code>7946/\{udp,tcp\}</code></li>
<li><code>4789/\{udp,tcp\}</code></li>
<li><code>\{2375,2376,2377,3375,3376\}/tcp</code> （具体端口取决于实际 <code>Swarm</code> 或 <code>Engine</code> 守护端口)</li>
</ul>
<p>可以通过 <code>telnet</code>, <code>curl</code> 之类的工具确保上述端口可以互访。</p>
<p>如果还是有问题，可以进一步启用各个节点的 Docker 引擎的调试模式。和配置 -<code>-insecure-registry</code> 的方法一样，编辑 Docker 配置文件，在 <code>dockerd</code> 后添加 <code>-D</code> 参数。然后重新启动 Docker 引擎，建立集群、网络、服务。如果问题重现，可以分析 <code>Docker</code> 引擎的日志，具体查看日志的方法见前面的问答。</p>
<p>需要注意的是，在 <code>1.13</code> 以前的版本中，跨宿主的情况下，无法在容器内 <code>ping</code> 到另一个服务的 <code>VIP</code>，这种情况，可以 <code>ping tasks.&lt;服务名&gt;</code>，来跳过 <code>VIP</code> 进行 <code>ping</code>。</p>
<p>参考：</p>
<p><a href="https://docs.docker.com/swarm/plan-for-production/" target="_blank" rel="noopener">https://docs.docker.com/swarm/plan-for-production/</a></p>
<p><a href="https://docs.docker.com/engine/swarm/swarm-tutorial/#/open-ports-between-the-hosts" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/swarm-tutorial/#/open-ports-between-the-hosts</a></p>
<p><a href="https://docs.docker.com/engine/swarm/networking/" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/networking/</a></p>
<hr>
<h3 id="Docker-二代Swarm-既-Swarm-Mode-，docker-service-create-不可以使用-v-那怎么使用卷-Volume-？"><a href="#Docker-二代Swarm-既-Swarm-Mode-，docker-service-create-不可以使用-v-那怎么使用卷-Volume-？" class="headerlink" title="Docker 二代Swarm (既 Swarm Mode)，docker service create 不可以使用 -v 那怎么使用卷(Volume)？"></a>Docker 二代Swarm (既 Swarm Mode)，docker service create 不可以使用 -v 那怎么使用卷(Volume)？</h3>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/12/个人/生活网站/" rel="next" title="生活网站">
                <i class="fa fa-chevron-left"></i> 生活网站
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/22/技术/zabbix/技术-zabbix3-4-1-介绍/" rel="prev" title="技术-zabbix3.4-1.介绍">
                技术-zabbix3.4-1.介绍 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/10/12/技术/docker/docker-3-问题篇/"
           data-title="docker-3-问题篇" data-url="https://luojieio.github.io/2017/10/12/技术/docker/docker-3-问题篇/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/teaser.png"
               alt="luojieio" />
          <p class="site-author-name" itemprop="name">luojieio</p>
           
              <p class="site-description motion-element" itemprop="description">热爱开源、热爱自由</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">103</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/luojieio" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cnblogs.com/alex3714/category/770733.html" title="金角大王" target="_blank">金角大王</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.runoob.com/" title="菜鸟教程" target="_blank">菜鸟教程</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://python.jobbole.com/" title="伯乐在线" target="_blank">伯乐在线</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://docs.docker.com/" title="Docker" target="_blank">Docker</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank">Hexo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://theme-next.iissnan.com/" title="NexT" target="_blank">NexT</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://fontawesome.io" title="Font Awesome" target="_blank">Font Awesome</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://duoshuo.com/" title="多说" target="_blank">多说</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念问题"><span class="nav-number">1.</span> <span class="nav-text">概念问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么-Docker-和虚拟机还有什么差别？"><span class="nav-number">1.1.</span> <span class="nav-text">宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么 Docker 和虚拟机还有什么差别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-资料好少啊？网上的命令怎么不能用？"><span class="nav-number">1.2.</span> <span class="nav-text">Docker 资料好少啊？网上的命令怎么不能用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何选择-Docker-书籍？"><span class="nav-number">1.3.</span> <span class="nav-text">如何选择 Docker 书籍？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-官网文档被墙，看不了怎么办？"><span class="nav-number">1.4.</span> <span class="nav-text">Docker 官网文档被墙，看不了怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-1-8-以后版本都有什么改进么？"><span class="nav-number">1.5.</span> <span class="nav-text">Docker 1.8 以后版本都有什么改进么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）docker与LXC（linux-container）有何不同"><span class="nav-number">1.6.</span> <span class="nav-text">（自加）docker与LXC（linux container）有何不同?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）docker与vagrant有何不同？"><span class="nav-number">1.7.</span> <span class="nav-text">（自加）docker与vagrant有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）开发环境中docker和vagrant该如何选择？"><span class="nav-number">1.8.</span> <span class="nav-text">（自加）开发环境中docker和vagrant该如何选择？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）docker能在非linux平台（比如windows或macos）上运行吗？"><span class="nav-number">1.9.</span> <span class="nav-text">（自加）docker能在非linux平台（比如windows或macos）上运行吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）docker的宿主系统是centos，为什么可以运行ubuntu的镜像呢？"><span class="nav-number">1.10.</span> <span class="nav-text">（自加）docker的宿主系统是centos，为什么可以运行ubuntu的镜像呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装、配置问题"><span class="nav-number">2.</span> <span class="nav-text">安装、配置问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-怎么这么多软件，我该装哪个？"><span class="nav-number">2.1.</span> <span class="nav-text">Docker 怎么这么多软件，我该装哪个？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是直接用-yum-apt-get-安装-Docker-吗？"><span class="nav-number">2.2.</span> <span class="nav-text">是直接用 yum / apt-get 安装 Docker 吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#17-04-及以后的版本"><span class="nav-number">2.2.1.</span> <span class="nav-text">17.04 及以后的版本:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-03-及以前的版本"><span class="nav-number">2.2.2.</span> <span class="nav-text">17.03 及以前的版本:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不是都已经发布-Docker-17-07-了么？我怎么升级到最新还是-17-05-呀？"><span class="nav-number">2.3.</span> <span class="nav-text">不是都已经发布 Docker 17.07 了么？我怎么升级到最新还是 17.05 呀？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-pull-好慢啊怎么办？"><span class="nav-number">2.4.</span> <span class="nav-text">docker pull 好慢啊怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用加速器？"><span class="nav-number">2.5.</span> <span class="nav-text">如何使用加速器？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ubuntu-14-04-配置加速器（或其它使用-Upstart-的系统）"><span class="nav-number">2.5.1.</span> <span class="nav-text">Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ubuntu-16-04-或-CentOS-7-配置加速器（或其它使用-Systemd-的系统）"><span class="nav-number">2.5.2.</span> <span class="nav-text">Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么修改了-docker-服务配置后不起作用？"><span class="nav-number">2.6.</span> <span class="nav-text">怎么修改了 docker 服务配置后不起作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果-Docker-升级或者重启的话，那容器是不是都会被停掉然后重启啊？"><span class="nav-number">2.7.</span> <span class="nav-text">如果 Docker 升级或者重启的话，那容器是不是都会被停掉然后重启啊？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么执行-docker-命令会报-permission-denied-没权限的错误啊？"><span class="nav-number">2.8.</span> <span class="nav-text">为什么执行 docker 命令会报 permission denied 没权限的错误啊？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）Docker的配置文件放在哪里，如何修改配置？"><span class="nav-number">2.9.</span> <span class="nav-text">（自加）Docker的配置文件放在哪里，如何修改配置？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何更改Docker的默认存储位置？"><span class="nav-number">2.10.</span> <span class="nav-text">（自加）如何更改Docker的默认存储位置？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）Cannot-connect-to-the-Docker-daemon-Is-‘docker-d’-running-on-this-host"><span class="nav-number">2.11.</span> <span class="nav-text">（自加）Cannot connect to the Docker daemon. Is ‘docker -d’ running on this host?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）dockser安装好后如何验证是否安装正常？"><span class="nav-number">2.12.</span> <span class="nav-text">（自加）dockser安装好后如何验证是否安装正常？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）因内核版本过低导致操作系统自动重启"><span class="nav-number">2.13.</span> <span class="nav-text">（自加）因内核版本过低导致操作系统自动重启</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）当你的内核版本已经支持了，也正常安装了，但是进程一开启就挂掉？"><span class="nav-number">2.14.</span> <span class="nav-text">（自加）当你的内核版本已经支持了，也正常安装了，但是进程一开启就挂掉？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器上线后，怎么发现总有个-xmrig-的容器在跑，删了还出来，这是什么鬼？"><span class="nav-number">2.15.</span> <span class="nav-text">服务器上线后，怎么发现总有个 xmrig 的容器在跑，删了还出来，这是什么鬼？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络问题"><span class="nav-number">3.</span> <span class="nav-text">网络问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么固定容器-IP-地址？每次重启容器都要变化-IP-地址怎么办？"><span class="nav-number">3.1.</span> <span class="nav-text">怎么固定容器 IP 地址？每次重启容器都要变化 IP 地址怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何修改容器的-etc-hosts-文件？"><span class="nav-number">3.2.</span> <span class="nav-text">如何修改容器的 /etc/hosts 文件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么映射宿主端口？Dockerfile-中的EXPOSE和-docker-run-p-有啥区别？"><span class="nav-number">3.3.</span> <span class="nav-text">怎么映射宿主端口？Dockerfile 中的EXPOSE和 docker run -p 有啥区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我要映射好几百个端口，难道要一个个-p-么？"><span class="nav-number">3.4.</span> <span class="nav-text">我要映射好几百个端口，难道要一个个 -p 么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-p-后还是无法通过映射端口访问容器里面的服务？"><span class="nav-number">3.5.</span> <span class="nav-text">为什么 -p 后还是无法通过映射端口访问容器里面的服务？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#本机防火墙"><span class="nav-number">3.5.1.</span> <span class="nav-text">本机防火墙</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#边界防火墙"><span class="nav-number">3.5.2.</span> <span class="nav-text">边界防火墙</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vethxxxx-这种虚拟网卡和容器的对应关系从哪里看？"><span class="nav-number">3.6.</span> <span class="nav-text">vethxxxx 这种虚拟网卡和容器的对应关系从哪里看？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何让一个容器连接两个网络？"><span class="nav-number">3.7.</span> <span class="nav-text">如何让一个容器连接两个网络？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-多宿主网络怎么配置？"><span class="nav-number">3.8.</span> <span class="nav-text">Docker 多宿主网络怎么配置？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#明明-docker-network-ls-中看到了建立的-overlay-网络，怎么-docker-run-还说网络不存在？"><span class="nav-number">3.9.</span> <span class="nav-text">明明 docker network ls 中看到了建立的 overlay 网络，怎么 docker run 还说网络不存在？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Swarm-Mode-时，看到有个叫-ingress-的-overlay-网络，它和自己创建的网络有什么区别？"><span class="nav-number">3.10.</span> <span class="nav-text">使用 Swarm Mode 时，看到有个叫 ingress 的 overlay 网络，它和自己创建的网络有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#听说-–link-过时不再用了？那容器互联、服务发现怎么办？"><span class="nav-number">3.11.</span> <span class="nav-text">听说 –link 过时不再用了？那容器互联、服务发现怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-HBase-Hadoop-的时候，反向解析总是不对，怎么办？"><span class="nav-number">3.12.</span> <span class="nav-text">使用 HBase/Hadoop 的时候，反向解析总是不对，怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器怎么取宿主机-IP-啊？"><span class="nav-number">3.13.</span> <span class="nav-text">容器怎么取宿主机 IP 啊？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单机环境"><span class="nav-number">3.13.1.</span> <span class="nav-text">单机环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群环境"><span class="nav-number">3.13.2.</span> <span class="nav-text">集群环境</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）docker导致服务器不定时死机，网络连接不上"><span class="nav-number">3.14.</span> <span class="nav-text">（自加）docker导致服务器不定时死机，网络连接不上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何删除docker0虚拟网桥"><span class="nav-number">3.15.</span> <span class="nav-text">（自加）如何删除docker0虚拟网桥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）创建docker容器后，在宿主机用“ip-netns-show”为何看不到容器的网络名字空间？"><span class="nav-number">3.16.</span> <span class="nav-text">（自加）创建docker容器后，在宿主机用“ip netns show”为何看不到容器的网络名字空间？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储问题"><span class="nav-number">4.</span> <span class="nav-text">存储问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何将一台宿主主机的docker环境迁移到另外一台宿主主机？"><span class="nav-number">4.1.</span> <span class="nav-text">（自加）如何将一台宿主主机的docker环境迁移到另外一台宿主主机？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像问题"><span class="nav-number">5.</span> <span class="nav-text">镜像问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-pull-下来的镜像文件都在哪？"><span class="nav-number">5.1.</span> <span class="nav-text">docker pull 下来的镜像文件都在哪？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-images-命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？"><span class="nav-number">5.2.</span> <span class="nav-text">docker images 命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-images-a-后显示了好多-lt-none-gt-的镜像？都是什么呀？能删么？"><span class="nav-number">5.3.</span> <span class="nav-text">docker images -a 后显示了好多 &lt;none&gt; 的镜像？都是什么呀？能删么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖镜像"><span class="nav-number">5.3.1.</span> <span class="nav-text">依赖镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#丢了标签的镜像"><span class="nav-number">5.3.2.</span> <span class="nav-text">丢了标签的镜像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-Docker-Hub-的镜像尺寸和-docker-images-不一致？"><span class="nav-number">5.4.</span> <span class="nav-text">为什么 Docker Hub 的镜像尺寸和 docker images 不一致？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-commit-怎么用啊？"><span class="nav-number">5.5.</span> <span class="nav-text">docker commit 怎么用啊？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么说不要使用-import-export-save-load-commit-来构建镜像？"><span class="nav-number">5.6.</span> <span class="nav-text">为什么说不要使用 import, export, save, load, commit 来构建镜像？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-怎么写？"><span class="nav-number">5.7.</span> <span class="nav-text">Dockerfile 怎么写？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-就是-shell-脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。"><span class="nav-number">5.8.</span> <span class="nav-text">Dockerfile 就是 shell 脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#那我把所有命令都合并到一个-RUN-就对了吧？"><span class="nav-number">5.9.</span> <span class="nav-text">那我把所有命令都合并到一个 RUN 就对了吧？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#context-到底是一个什么概念？"><span class="nav-number">5.10.</span> <span class="nav-text">context 到底是一个什么概念？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENTRYPOINT-和-CMD-到底有什么不同？"><span class="nav-number">5.11.</span> <span class="nav-text">ENTRYPOINT 和 CMD 到底有什么不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拿到一个镜像，如何获得镜像的-Dockerfile-？"><span class="nav-number">5.12.</span> <span class="nav-text">拿到一个镜像，如何获得镜像的 Dockerfile ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在你的-LNMP-的例子中，PHP-的-Dockerfile-里面的-“构建依赖”-和-“运行依赖”-都是什么意思？"><span class="nav-number">5.13.</span> <span class="nav-text">在你的 LNMP 的例子中，PHP 的 Dockerfile 里面的 “构建依赖” 和 “运行依赖” 都是什么意思？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用代码是应该挂载宿主目录还是放入镜像内？"><span class="nav-number">5.14.</span> <span class="nav-text">应用代码是应该挂载宿主目录还是放入镜像内？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么在-Dockerfile-中执行（导入-sql、service-xxx-start）不管用？"><span class="nav-number">5.15.</span> <span class="nav-text">为什么在 Dockerfile 中执行（导入 .sql、service xxx start）不管用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么基于-Alpine-的镜像那么小？我可以都换成基于-Alpine-的镜像么？"><span class="nav-number">5.16.</span> <span class="nav-text">为什么基于 Alpine 的镜像那么小？我可以都换成基于 Alpine 的镜像么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以看到镜像各层的依赖关系么？"><span class="nav-number">5.17.</span> <span class="nav-text">可以看到镜像各层的依赖关系么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何批量清理临时镜像文件？"><span class="nav-number">5.18.</span> <span class="nav-text">（自加）如何批量清理临时镜像文件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何查看镜像支持的环境变量？"><span class="nav-number">5.19.</span> <span class="nav-text">（自加）如何查看镜像支持的环境变量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）构建docker镜像应该遵循哪些原则？"><span class="nav-number">5.20.</span> <span class="nav-text">（自加）构建docker镜像应该遵循哪些原则？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）安装完成docker后使用docker-pull-NAME-拉取镜像时失败报错问题：dial-unix-var-run-docker-sock-no-such-file-or-directory"><span class="nav-number">5.21.</span> <span class="nav-text">（自加）安装完成docker后使用docker pull NAME 拉取镜像时失败报错问题：dial unix /var/run/docker.sock: no such file or directory.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）docker做的ssh镜像，启动ssh服务时，提示Could-not-load-host-key-etc-ssh-ssh-host-rsa-key"><span class="nav-number">5.22.</span> <span class="nav-text">（自加）docker做的ssh镜像，启动ssh服务时，提示Could not load host key: /etc/ssh/ssh_host_rsa_key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）构建镜像时的构建层会被删除吗？"><span class="nav-number">5.23.</span> <span class="nav-text">（自加）构建镜像时的构建层会被删除吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）镜像会继承吗？"><span class="nav-number">5.24.</span> <span class="nav-text">（自加）镜像会继承吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）构建镜像有commit和Dockerfile两种方式，推荐用哪种？为什么？"><span class="nav-number">5.25.</span> <span class="nav-text">（自加）构建镜像有commit和Dockerfile两种方式，推荐用哪种？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）构建出的镜像体量太大，怎么精简点？"><span class="nav-number">5.26.</span> <span class="nav-text">（自加）构建出的镜像体量太大，怎么精简点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）使用Dockerfile构建镜像时，为优化镜像容量，是否可以使用-amp-amp-＼来减少关键字使用？"><span class="nav-number">5.27.</span> <span class="nav-text">（自加）使用Dockerfile构建镜像时，为优化镜像容量，是否可以使用&amp;&amp;　＼来减少关键字使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）构建镜像时，明明Dockerfile中所引用的内容作了更新，为什么docker-仍然使用原来的缓存，不进行更新呢？"><span class="nav-number">5.28.</span> <span class="nav-text">（自加）构建镜像时，明明Dockerfile中所引用的内容作了更新，为什么docker 仍然使用原来的缓存，不进行更新呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）写Dockerfile可以加注释吗？"><span class="nav-number">5.29.</span> <span class="nav-text">（自加）写Dockerfile可以加注释吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）为什么使用Dockerfile构建时明明下载到-tmp目录的文件，在构建的下一个语句时就没有了？"><span class="nav-number">5.30.</span> <span class="nav-text">（自加）为什么使用Dockerfile构建时明明下载到/tmp目录的文件，在构建的下一个语句时就没有了？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器问题"><span class="nav-number">6.</span> <span class="nav-text">容器问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）容器退出后，通过docker-ps-命令查看不到，数据会丢失吗？"><span class="nav-number">6.1.</span> <span class="nav-text">（自加）容器退出后，通过docker ps 命令查看不到，数据会丢失吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何停止所有正在运行的容器？"><span class="nav-number">6.2.</span> <span class="nav-text">（自加）如何停止所有正在运行的容器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何清理批量所有容器？"><span class="nav-number">6.3.</span> <span class="nav-text">（自加）如何清理批量所有容器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何给容器指定一个固定IP地址，而不是每次重启容器IP地址都会变？"><span class="nav-number">6.4.</span> <span class="nav-text">（自加）如何给容器指定一个固定IP地址，而不是每次重启容器IP地址都会变？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何临时退出一个正在交互的容器的终端，而不终止它？"><span class="nav-number">6.5.</span> <span class="nav-text">（自加）如何临时退出一个正在交互的容器的终端，而不终止它？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）使用“docker-port”命令映射容器的端口时，系统报错Error：No-public-port-‘80’-published-for-e7d817698b6f，是什么意思？"><span class="nav-number">6.6.</span> <span class="nav-text">（自加）使用“docker port”命令映射容器的端口时，系统报错Error：No public port ‘80’ published for e7d817698b6f，是什么意思？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）可以在一个容器中同时运行多个应用进程吗？"><span class="nav-number">6.7.</span> <span class="nav-text">（自加）可以在一个容器中同时运行多个应用进程吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何控制容器占用系统资源（CPU-内存）的份额？"><span class="nav-number">6.8.</span> <span class="nav-text">（自加）如何控制容器占用系统资源（CPU/内存）的份额？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）容器中的文件系统是自身的吗？"><span class="nav-number">6.9.</span> <span class="nav-text">（自加）容器中的文件系统是自身的吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）run容器时带不带cmd都可以吗？"><span class="nav-number">6.10.</span> <span class="nav-text">（自加）run容器时带不带cmd都可以吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）run容器时，把宿主机上的文件通过-v挂载到容器了怎么没有？"><span class="nav-number">6.11.</span> <span class="nav-text">（自加）run容器时，把宿主机上的文件通过-v挂载到容器了怎么没有？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）挂载数据卷容器如果容器处于停止状态是否可用？"><span class="nav-number">6.12.</span> <span class="nav-text">（自加）挂载数据卷容器如果容器处于停止状态是否可用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）容器中的数据如何实现迁移？"><span class="nav-number">6.13.</span> <span class="nav-text">（自加）容器中的数据如何实现迁移？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）run运行容器时加不加-d的区别？"><span class="nav-number">6.14.</span> <span class="nav-text">（自加）run运行容器时加不加-d的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）run运行容器时，什么时候需要加-ti？"><span class="nav-number">6.15.</span> <span class="nav-text">（自加）run运行容器时，什么时候需要加-ti？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）对内服务是否一定要用–link才可以？"><span class="nav-number">6.16.</span> <span class="nav-text">（自加）对内服务是否一定要用–link才可以？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）如何才能用容器外的设备来访问容器内的apache服务呢？"><span class="nav-number">6.17.</span> <span class="nav-text">（自加）如何才能用容器外的设备来访问容器内的apache服务呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）容器中的的进程一定要前台运行吗？"><span class="nav-number">6.18.</span> <span class="nav-text">（自加）容器中的的进程一定要前台运行吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）使用commit方式构建将容器提交为镜像时需要停止吗？停止和不停止的区别是什么？"><span class="nav-number">6.19.</span> <span class="nav-text">（自加）使用commit方式构建将容器提交为镜像时需要停止吗？停止和不停止的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）单个容器如何运行多个进程？"><span class="nav-number">6.20.</span> <span class="nav-text">（自加）单个容器如何运行多个进程？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#仓库问题"><span class="nav-number">7.</span> <span class="nav-text">仓库问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？"><span class="nav-number">7.1.</span> <span class="nav-text">（自加）仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）从非官方仓库下载镜像的时候，有时候会提示“Error-Invalid-registry-endpoint-……-”？"><span class="nav-number">7.2.</span> <span class="nav-text">（自加）从非官方仓库下载镜像的时候，有时候会提示“Error:Invalid registry endpoint ……..”？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（自加）registry有多少版本？"><span class="nav-number">7.3.</span> <span class="nav-text">（自加）registry有多少版本？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日志问题"><span class="nav-number">8.</span> <span class="nav-text">日志问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-日志都在哪里？怎么收集？"><span class="nav-number">8.1.</span> <span class="nav-text">Docker 日志都在哪里？怎么收集？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker-引擎日志"><span class="nav-number">8.1.1.</span> <span class="nav-text">Docker 引擎日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器日志"><span class="nav-number">8.1.2.</span> <span class="nav-text">容器日志</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同容器的日志汇聚到-fluentd-后如何区分？"><span class="nav-number">8.2.</span> <span class="nav-text">不同容器的日志汇聚到 fluentd 后如何区分？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用问题"><span class="nav-number">9.</span> <span class="nav-text">使用问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么容器一运行就退出啊？"><span class="nav-number">9.1.</span> <span class="nav-text">为什么容器一运行就退出啊？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何在-Docker-容器内使用-docker-命令-比如在-Jenkins-容器中-？"><span class="nav-number">9.2.</span> <span class="nav-text">如何在 Docker 容器内使用 docker 命令(比如在 Jenkins 容器中)？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为-Jenkins-添加-Docker-命令行"><span class="nav-number">9.2.1.</span> <span class="nav-text">为 Jenkins 添加 Docker 命令行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-容器如何随系统一同启动？"><span class="nav-number">9.3.</span> <span class="nav-text">Docker 容器如何随系统一同启动？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-stats-显示的只有容器ID，怎么才能显示容器名字？"><span class="nav-number">9.4.</span> <span class="nav-text">docker stats 显示的只有容器ID，怎么才能显示容器名字？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我用的是阿里云-Ubuntu-14-04-主机，内核还是3-13，怎么办？"><span class="nav-number">9.5.</span> <span class="nav-text">我用的是阿里云 Ubuntu 14.04 主机，内核还是3.13，怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何动态修改内存限制？"><span class="nav-number">9.6.</span> <span class="nav-text">如何动态修改内存限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经常在各种-Docker-命令里看到-–label，label-是什么？干什么用的？"><span class="nav-number">9.7.</span> <span class="nav-text">经常在各种 Docker 命令里看到 –label，label 是什么？干什么用的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#添加label以及过滤"><span class="nav-number">9.7.1.</span> <span class="nav-text">添加label以及过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群调度约束"><span class="nav-number">9.7.2.</span> <span class="nav-text">集群调度约束</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#都说不要用-root-去运行服务，但我看到的-Dockerfile-都是用-root-去运行，这不安全吧？"><span class="nav-number">9.8.</span> <span class="nav-text">都说不要用 root 去运行服务，但我看到的 Dockerfile 都是用 root 去运行，这不安全吧？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我在容器里运行-systemctl-start-xxx-怎么报错啊？"><span class="nav-number">9.9.</span> <span class="nav-text">我在容器里运行 systemctl start xxx 怎么报错啊？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器内的时间和宿主不一致，怎么同步啊？"><span class="nav-number">9.10.</span> <span class="nav-text">容器内的时间和宿主不一致，怎么同步啊？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我想让我的程序平滑退出，为什么截获-SIGTERM-信号不管用啊？"><span class="nav-number">9.11.</span> <span class="nav-text">我想让我的程序平滑退出，为什么截获 SIGTERM 信号不管用啊？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Compose-相关问题"><span class="nav-number">10.</span> <span class="nav-text">Docker Compose 相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#你那个-LNMP-例子中的-docker-compose-yml-中有好多-networks，都是什么意思啊？"><span class="nav-number">10.1.</span> <span class="nav-text">你那个 LNMP 例子中的 docker-compose.yml 中有好多 networks，都是什么意思啊？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Compose-的时候碰到-“An-HTTP-request-took-too-long-to-complete…-”-错误，怎么办？"><span class="nav-number">10.2.</span> <span class="nav-text">使用 Compose 的时候碰到 “An HTTP request took too long to complete….” 错误，怎么办？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Swarm-相关问题"><span class="nav-number">11.</span> <span class="nav-text">Docker Swarm 相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#我的-Docker-版本是-1-12，请问我跑的是一代-Swarm-还是二代-Swarm-啊？"><span class="nav-number">11.1.</span> <span class="nav-text">我的 Docker 版本是 1.12，请问我跑的是一代 Swarm 还是二代 Swarm 啊？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swarm环境中怎么指定某个容器在指定的宿主上运行呢？"><span class="nav-number">11.2.</span> <span class="nav-text">Swarm环境中怎么指定某个容器在指定的宿主上运行呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-Swarm-集群的-overlay-network-跨宿主无法互访？"><span class="nav-number">11.3.</span> <span class="nav-text">为什么 Swarm 集群的 overlay network 跨宿主无法互访？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-二代Swarm-既-Swarm-Mode-，docker-service-create-不可以使用-v-那怎么使用卷-Volume-？"><span class="nav-number">11.4.</span> <span class="nav-text">Docker 二代Swarm (既 Swarm Mode)，docker service create 不可以使用 -v 那怎么使用卷(Volume)？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luojieio</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"luojieio-note"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="local-search-pop-overlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


  

</body>
</html>
